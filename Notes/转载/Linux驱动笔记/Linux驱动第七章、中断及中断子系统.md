# ç¬¬ä¸€èŠ‚ã€ä¸­æ–­æ¦‚å¿µï¼š

## 1. ä»€ä¹ˆæ˜¯ä¸­æ–­ï¼š

### 1.1ä¸ºä»€ä¹ˆè¦æœ‰ä¸­æ–­?**ğŸ¤”**

å¤„ç†å™¨é€Ÿåº¦å¾ˆå¿«ï¼Œå¤–å›´è®¾å¤‡é€Ÿåº¦å¾€å¾€ä¸åœ¨ä¸€ä¸ªæ•°é‡çº§ä¸Šï¼Œå¦‚æœå¤„ç†å™¨ç»™ç¡¬ä»¶å‘å‡ºä¸€ä¸ªè¯·æ±‚ï¼Œå†ä¸“é—¨ç­‰å›åº”ï¼Œæ˜¾ç„¶æ˜¯æµªè´¹äº†cpuçš„å¤„ç†å…¶å®ƒäº‹åŠ¡çš„èƒ½åŠ›ï¼Œæ‰€ä»¥é‡‡å–å½“å¤–å›´ç¡¬ä»¶å¤„ç†å¥½è‡ªå·±çš„äº‹ä»¶ï¼Œå†æ¥å‘è¯·æ±‚çš„æ—¶å€™ï¼Œå¤„ç†å™¨å†å›å¤´å¤„ç†å®ƒã€‚

æ¯”å¦‚ï¼šç½‘å¡æ¥æ”¶åˆ°æ•°æ®æ—¶ï¼Œå¯èƒ½ä¼šå› ä¸ºç½‘ç»œä¼ è¾“çš„é—®é¢˜ï¼Œä¼šç­‰å¾…ä¸€æ®µæ—¶é—´æ‰èƒ½æ¥æ”¶åˆ°å®Œæ•´çš„æ•°æ®ï¼Œä½†æ˜¯cpuä¸ä¼šç­‰ç½‘å¡è®¾å¤‡æ¥æ”¶å®Œå†æ¥å¤„ç†çš„ï¼Œè€Œæ˜¯ç»§ç»­æ‰§è¡Œcpuçš„ä»»åŠ¡ï¼Œå½“ç½‘å¡æ¥æ”¶å®Œæ•°æ®ä¹‹åï¼Œç½‘å¡ç»™cpuçš„ä¸­æ–­æ§åˆ¶å™¨å‘ä¸€ä¸ªç”µä¿¡å·ï¼Œä¸­æ–­æ§åˆ¶å™¨å†æ ¹æ®ç”µä¿¡å·ç»™cpuå‘å‡ºè¯·æ±‚ï¼Œcpuæ¥æ”¶ä¸­æ–­è¯·æ±‚ä¹‹åï¼Œä¼šä¿å­˜å½“å‰æ‰§è¡Œçš„ä»»åŠ¡çš„ä¸Šä¸‹æ–‡ï¼Œç„¶åå»å¤„ç†è¿™ä¸ªä¸­æ–­è¯·æ±‚å¯¹åº”çš„å¤„ç†å‡½æ•°ï¼Œå¤„ç†å®Œæˆä¹‹åï¼Œå†æ ¹æ®ä¹‹å‰ä¿å­˜çš„ä¸Šä¸‹æ–‡å†æ¬¡å›ä»»åŠ¡æ‰§è¡Œå¤„ã€‚

è¿™ç§ç”±ç¡¬ä»¶å½“æ»¡è¶³ä¸€å®šæ¡ä»¶å°±å‘ä¸­æ–­æ§åˆ¶å™¨å‘å‡ºçš„ç”µä¿¡å·å°±æ˜¯ä¸€ä¸ªä¸­æ–­ã€‚

é€šè¿‡ä»¥ä¸Šçš„ä¸­æ–­çš„æ–¹å¼ï¼Œå¯ä»¥å¤§å¤§æé«˜cpuçš„å®æ—¶å¤„ç†ä»»åŠ¡çš„èƒ½åŠ›ï¼Œè€Œéç­‰å¾…æˆ–è½®è¯¢ã€‚æ‰€ä»¥è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¦æœ‰ä¸­æ–­çš„åŸå› ã€‚

ç°åœ¨æ“ä½œç³»ç»Ÿå…³äºä¸­æ–­å·²ç»å¹¿ä¹‰çš„è¯´æ³•äº†ï¼Œå¯¹äºç³»ç»Ÿè€Œè¨€ï¼Œä¸ºäº†å¯¹è¿›ç¨‹çš„è°ƒåº¦åŠçŠ¶æ€åˆ‡æ¢ï¼Œåœ¨ç³»ç»Ÿè½¯ä»¶å±‚ä¹Ÿå®ç°äº†ä¸ä¾èµ–äºä¸­æ–­æ§åˆ¶å™¨çš„è½¯ä»¶ä¸­æ–­ï¼Œé€šå¸¸æ˜¯ç¨‹åºé€šè¿‡ç‰¹å®šæŒ‡ä»¤ï¼ˆå¦‚x86æ¶ä¸­çš„INTæ±‡ç¼–æŒ‡ä»¤ï¼ŒARMæ¶æ„ä¸­SWIæ±‡ç¼–æŒ‡ä»¤ï¼‰ä¸»åŠ¨è§¦å‘çš„ä¸­æ–­ã€‚æ¯”å¦‚å…è®¸ç”¨æˆ·ç¨‹åºè¯·æ±‚æ“ä½œç³»ç»Ÿæä¾›æœåŠ¡çš„ç³»ç»Ÿè°ƒç”¨å°±æ˜¯è½¯ä»¶ä¸­æ–­ã€‚

æ‰€ä»¥è¯´ä¸­æ–­æ˜¯ç³»ç»Ÿå®ç°å®æ—¶æ€§çš„æ ¸å¿ƒã€‚

é‚£ä¹ˆç¡¬ä»¶ä¸­æ–­ä¸è½¯ä»¶ä¸­æ–­æœ‰ä»€ä¹ˆåŒºåˆ«å—ï¼Ÿ

## **2.ä¸­æ–­çš„åˆ†ç±»ï¼š **

### 2.1ç¡¬ä»¶ä¸­æ–­ï¼ˆHardware Interruptï¼‰

**å®šä¹‰**

**ç‰¹ç‚¹**

1. **å¼‚æ­¥ï¼š**ä¸ä¾èµ–äºCPUå½“å‰æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œå¯ä»¥åœ¨ä»»ä½•æ—¶å€™å‘ç”Ÿã€‚

1. **é«˜ä¼˜å…ˆçº§**ï¼šé€šå¸¸æ¯”æ™®é€šçš„ç¨‹åºæ‰§è¡Œä¼˜å…ˆçº§é«˜ï¼Œèƒ½å¤Ÿæ‰“æ–­å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤åºåˆ—ã€‚

1. **å“åº”é€Ÿåº¦å¿«ï¼š**ç¡¬ä»¶ä¸­æ–­çš„è®¾è®¡ç›®çš„æ˜¯ä¸ºäº†å¿«é€Ÿå“åº”å¤–éƒ¨è®¾å¤‡çš„è¯·æ±‚ã€‚

**åº”ç”¨åœºæ™¯**

- å½“é”®ç›˜è¢«æŒ‰ä¸‹æ—¶ï¼Œç”Ÿæˆé”®ç›˜ä¸­æ–­ã€‚

- å½“ç½‘ç»œæ¥å£æ¥æ”¶åˆ°æ•°æ®åŒ…æ—¶ï¼Œç”Ÿæˆç½‘ç»œä¸­æ–­ã€‚

- ç¡¬ç›˜è¯»å–æˆ–å†™å…¥å®Œæˆæ—¶ï¼Œç”Ÿæˆç¡¬ç›˜ä¸­æ–­ã€‚

**å¤„ç†è¿‡ç¨‹**

1. ç¡¬ä»¶è®¾å¤‡å‘é€ä¸­æ–­ä¿¡å·ç»™ä¸­æ–­æ§åˆ¶å™¨ï¼Œä¸­æ–­æ§åˆ¶å™¨åˆ†é…CPUå¤„ç†ç›¸åº”çš„ä¸­æ–­ä»»åŠ¡ã€‚

1. CPUæš‚æ—¶åœæ­¢å½“å‰çš„æŒ‡ä»¤æ‰§è¡Œï¼Œä¿å­˜å½“å‰çŠ¶æ€ã€‚

1. CPUè·³è½¬åˆ°å¯¹åº”çš„ä¸­æ–­å¤„ç†ç¨‹åºï¼ˆInterrupt Service Routineï¼ŒISRï¼‰æ¥å¤„ç†ä¸­æ–­ã€‚

1. å¤„ç†å®Œæˆåï¼Œæ¢å¤ä¹‹å‰çš„çŠ¶æ€å¹¶ç»§ç»­æ‰§è¡Œè¢«æ‰“æ–­çš„ç¨‹åºã€‚

### 2.2è½¯ä»¶ä¸­æ–­ï¼ˆSoftware Interruptï¼‰

**å®šä¹‰**

**ç‰¹ç‚¹**

1. **åŒæ­¥ï¼š**ç”±ç¨‹åºæ‰§è¡Œç‰¹å®šæŒ‡ä»¤è§¦å‘ï¼Œå‘ç”Ÿåœ¨ç¨‹åºæ§åˆ¶ä¹‹å†…ã€‚

1. **å¯æ§æ€§ï¼š**ç¨‹åºå‘˜å¯ä»¥å†³å®šä½•æ—¶è§¦å‘è½¯ä»¶ä¸­æ–­ã€‚

1. **ä¸ç¡¬ä»¶æ— å…³ï¼š**ä¸ä¾èµ–äºå¤–éƒ¨ç¡¬ä»¶è®¾å¤‡ï¼Œå®Œå…¨ç”±è½¯ä»¶é€»è¾‘æ§åˆ¶ã€‚

**åº”ç”¨åœºæ™¯**

- ç”¨æˆ·ç¨‹åºéœ€è¦æ“ä½œç³»ç»Ÿçš„æœåŠ¡ï¼ˆå¦‚æ–‡ä»¶è¯»å†™ã€å†…å­˜åˆ†é…ç­‰ï¼‰æ—¶ï¼Œè§¦å‘è½¯ä»¶ä¸­æ–­è¿›è¡Œç³»ç»Ÿè°ƒç”¨ã€‚

- ç¨‹åºå¼‚å¸¸å¤„ç†ï¼ˆå¦‚é™¤é›¶é”™è¯¯ã€éæ³•è®¿é—®ç­‰ï¼‰ï¼Œé€šè¿‡è½¯ä»¶ä¸­æ–­å¤„ç†å¼‚å¸¸æƒ…å†µã€‚

**å¤„ç†è¿‡ç¨‹**

1. ç¨‹åºæ‰§è¡Œè§¦å‘ä¸­æ–­çš„æŒ‡ä»¤ã€‚

1. CPUå“åº”ä¸­æ–­ï¼Œä¿å­˜å½“å‰çŠ¶æ€ã€‚

1. CPUè·³è½¬åˆ°å¯¹åº”çš„ä¸­æ–­å¤„ç†ç¨‹åºï¼ˆé€šå¸¸æ˜¯æ“ä½œç³»ç»Ÿæä¾›çš„ç³»ç»Ÿè°ƒç”¨å¤„ç†ç¨‹åºï¼‰ã€‚

1. å¤„ç†å®Œæˆåï¼Œæ¢å¤ä¹‹å‰çš„çŠ¶æ€å¹¶ç»§ç»­æ‰§è¡Œç¨‹åºã€‚

### 2.3å¯¹æ¯”æ€»ç»“ï¼š

- **è§¦å‘æ–¹å¼ï¼š**

- ç¡¬ä»¶ä¸­æ–­ï¼šç”±å¤–éƒ¨ç¡¬ä»¶è®¾å¤‡è§¦å‘ã€‚

- è½¯ä»¶ä¸­æ–­ï¼šç”±ç¨‹åºæŒ‡ä»¤è§¦å‘ã€‚

- **æ—¶æœºï¼š**

- ç¡¬ä»¶ä¸­æ–­ï¼šå¼‚æ­¥ï¼Œå¯ä»¥åœ¨ä»»ä½•æ—¶å€™å‘ç”Ÿã€‚

- è½¯ä»¶ä¸­æ–­ï¼šåŒæ­¥ï¼Œåœ¨ç¨‹åºæ‰§è¡Œä¸­ä¸»åŠ¨è§¦å‘ã€‚

- **åº”ç”¨ï¼š**

- ç¡¬ä»¶ä¸­æ–­ï¼šå“åº”å¤–éƒ¨è®¾å¤‡çš„è¯·æ±‚ã€‚

- è½¯ä»¶ä¸­æ–­ï¼šå®ç°ç³»ç»Ÿè°ƒç”¨å’Œå¼‚å¸¸å¤„ç†ã€‚

**æ€»ç»“**

**ä¸è¿‡è½¯ä»¶ä¸­æ–­éƒ½å·²ç»ç”±ç³»ç»Ÿæ„å»ºå¥½ï¼Œæˆ‘ä»¬è¿™é‡Œä¸»è¦å­¦ä¹ çš„æ˜¯ç¡¬ä»¶ä¸­æ–­ã€‚**

## **3.å…¶å®ƒçš„åˆ†ç±»æ–¹å¼ï¼ˆæ ¹æ®ä¸­æ–­å·åˆ†ç±»ï¼‰ï¼š**

![](images/WEBRESOURCEd85967215aa215773f45296f8ae028dbimage.png)

MP157aèŠ¯ç‰‡ä¸­æ–­æ§åˆ¶å™¨GICå†…éƒ¨æ¡†å›¾ï¼š

![](images/WEBRESOURCE4703b5ec2da2df9efaad1886abee515fimage.png)

![](images/WEBRESOURCEed153a3067b5bf42cc0e9e428f54ef50image.png)

# ç¬¬äºŒèŠ‚ã€**ä¸­æ–­å¤„ç†å®ç°åŸç†ï¼š**

## 1.ç¡¬ä»¶ä¸­æ–­çš„å¤„ç†çš„ç»“æ„æ¡†å›¾ï¼š

ä»¥æŒ‰é”®è®¾å¤‡ç‚¹å‡»ä¸€ä¸‹å‡ºç°çš„ä¸­æ–­ä¸ºä¾‹ï¼š

![](images/WEBRESOURCE507b3d1c6a5301067d78a4d9731f2578image.png)

## 2.ç¡¬ä»¶ä¸­æ–­å¤„ç†çš„ç®€åŒ–æµç¨‹ï¼š

![](images/WEBRESOURCE63468d328e05b27d17e79fe935192015image.png)

## 3.**è®¾å¤‡æ ‘èŠ‚ç‚¹ä¸­æ–­å¼•è„šèµ„æºçš„æè¿°æ–¹å¼ï¼Œç¤ºä¾‹æŒ‰é”®ï¼š**

![](images/WEBRESOURCE9627dad4e8f2ce69e28cd565aa8be964image.png)

key1 = PF9,   key2 = PF7, Key3 = PF8

```cpp
//åœ¨è®¾å¤‡æ ‘ä¸­çš„è®¾å¤‡èŠ‚ç‚¹ä½¿ç”¨ä¸­æ–­èµ„æºçš„æ–¹å¼ã€‚
/{
    ...
Â  Â  mykey{
Â  Â  Â  Â  compatible = "WX,my_device_key";
Â  Â  Â  Â  dev_type = "KEY";
Â  Â  Â  Â  interrupt-parent = <&gpiof>;
Â  Â  Â  Â  //key1 = PF9, Â  key2 = PF7, Key3 = PF8
Â  Â  Â  Â  interrupts = <9 0>,<7 0>,<8 0>;
Â  Â  Â  Â  status = "okay";
Â  Â  };
};
```

# ç¬¬ä¸‰èŠ‚ã€Linuxä¸­æ–­å­ç³»ç»Ÿä½¿ç”¨ï¼š

## 1. ä¸­æ–­å­ç³»ç»Ÿæ¡†æ¶ï¼š

![](images/WEBRESOURCEc07a98c3c45213ddc9c92ffa463b3e51image.png)

## 2. linuxç³»ç»Ÿä¸­æ–­å·ï¼šLinux IRQ number:

LinuxæŠŠä¸­æ–­æ§åˆ¶å™¨ç›¸å…³çš„å¯„å­˜å™¨è¿›è¡Œä¸Šå±‚çš„æŠ½è±¡ä¸å°è£…ï¼Œå®ç°äº†ä¸Šå±‚çš„ç»Ÿä¸€ï¼Œå±è”½äº†ç¡¬ä»¶çš„ä¸­æ–­æ§åˆ¶å™¨çš„å·®å¼‚ï¼Œç»™é©±åŠ¨çš„ç¼–å†™å¸¦æ¥äº†ç»Ÿä¸€ã€‚Linuxå­ç³»ç»Ÿå¯¹äºä¸­æ–­èµ„æºçš„æè¿°ä½¿ç”¨ä¸­æ–­å·æ¥è¡¨ç¤ºæŒ‡å®šçš„ä¸­æ–­èµ„æºã€‚ä¸­æ–­å·æ˜¯ç³»ç»Ÿå”¯ä¸€çš„ï¼Œä»£è¡¨äº†æŸä¸ªè®¾å¤‡æŸä¸ªå¼•è„šä¸Šçš„ä¸­æ–­çš„ä½¿ç”¨ã€‚

åœ¨linuxç³»ç»Ÿä¸­çš„ä¸­æ–­å·æ˜¯å”¯ä¸€çš„ï¼Œä¹Ÿæ˜¯ä¸­æ–­å­ç³»ç»Ÿæ ‡è¯†ä¸­æ–­èµ„æºçš„å”¯ä¸€çš„æ–¹å¼ã€‚linuxä¸­æ–­å­ç³»ç»Ÿæä¾›çš„æ¥å£ä¼šæ ¹æ®ç›¸åº”çš„ä¸­æ–­å¼•è„šç¼–å·è§£é‡Šå‡ºç›¸åº”çš„ç³»ç»Ÿä¸­æ–­å·ã€‚

### **2.1APIè·å–linuxä¸­æ–­å·çš„æ–¹å¼ï¼š**

#### **1. å¦‚æœè®¾å¤‡æ ‘èŠ‚ç‚¹å¯ä»¥è½¬æ¢ä¸ºplatform_deviceèŠ‚ç‚¹çš„ï¼Œå¯ä»¥ä½¿ç”¨platform_get_resourceæŒ‡å®šä¸­æ–­èµ„æºç±»å‹IRQRESOURCEå³å¯è·å¾—ã€‚**

#### **2. å¦‚æœä¸èƒ½è½¬æ¢ä¸ºplatform_deviceèŠ‚ç‚¹çš„è®¾å¤‡ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨of_get_irqè·å¾—ï¼Œå½“ç„¶platform_deviceæ›´å¯ä»¥ç”¨ï¼š**

```cpp
int of_irq_get(struct device_node *dev, int index);
è§£æä¸€ä¸ªèŠ‚ç‚¹çš„IRQå¹¶å°†å…¶ä½œä¸ºLinux IRQç¼–å·è¿”å› 
@dev: æŒ‡å‘è®¾å¤‡æ ‘èŠ‚ç‚¹çš„æŒ‡é’ˆ 
@index: IRQçš„ä»é›¶å¼€å§‹çš„ç´¢å¼• 
è¿”å›å€¼: * æˆåŠŸæ—¶è¿”å›Linux IRQç¼–å·ï¼› 
å¦‚æœIRQæ˜ å°„å¤±è´¥ï¼Œåˆ™è¿”å›0ï¼›
å¦‚æœIRQåŸŸå°šæœªåˆ›å»ºï¼Œåˆ™è¿”å›-EPROBE_DEFERï¼›
å…¶ä»–ä»»ä½•å¤±è´¥æƒ…å†µä¸‹è¿”å›é”™è¯¯ä»£ç ã€‚ 
```

## å¸¸ç”¨çš„è§£é‡Šè®¾å¤‡æ ‘èŠ‚ç‚¹çš„ofæ“ä½œå‡½æ•°ï¼šè·å–device_node:

```cpp
struct device_node *of_find_node_by_path(const char *path);
//åŠŸèƒ½ï¼šé€šè¿‡æ˜¯å­—ç¬¦ä¸²æè¿°çš„èŠ‚ç‚¹è·¯å¾„ï¼Œè¿”å›ä¸€ä¸ªè®¾å¤‡èŠ‚ç‚¹ç»“æ„ä½“å¯¹è±¡æŒ‡é’ˆã€‚
//æˆåŠŸï¼šæ‰¾åˆ°è¿”å›æŒ‡å‘ç»“æ„ä½“å¯¹è±¡çš„æŒ‡é’ˆï¼Œæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›NULL;
```

å…¶å®ƒçš„ofæ“ä½œå‡½æ•°ï¼Œå¤§å®¶è‡ªè¡Œç™¾åº¦æŸ¥æ‰¾ã€‚

## 2.è¯·æ±‚Linuxä¸­æ–­å·èµ„æºåŠæŒ‡å®šä¸­æ–­æœåŠ¡ä¾‹ç¨‹ISRï¼ˆä¸­æ–­ä¸Šæ–‡ï¼‰:request_irq:

```cpp
int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,const char *name, void *dev);
å‡½æ•°ä½œç”¨ï¼šè¯·æ±‚ä¸­æ–­å¹¶æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åºçš„å‡½æ•°ï¼Œç»™è°ƒç”¨BSPåŸå‚ä¸­æ–­æ§åˆ¶å™¨çš„é©±åŠ¨è¿›è¡Œç›¸å…³å¯„å­˜å™¨è¿›è¡Œè®¾ç½®ã€‚
å‡½æ•°å‚æ•°ï¼š
1.irq:ä¸­æ–­å·ï¼Œæ˜¯æŒ‡è¦è¯·æ±‚çš„Linuxä¸­æ–­å·ã€‚
2.handle:ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œç±»å‹ï¼štypedef irqreturn_t (*irq_handler_t)(int irq, void* dev),å°±æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ.
å›è°ƒå‡½æ•°çš„ä¸­çš„å‚æ•°irq å³ä¸ºä¸­æ–­å·ï¼Œå‚æ•°devå³ä¼ é€’è¿‡æ¥çš„devæœ€åä¸€ä¸ªå‚æ•°ã€‚
å›è°ƒå‡½æ•°è¿”å›å€¼æ˜¯irqreturn_t æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹æœ‰ä¸‰ä¸ªå€¼ï¼š
enum irqreturn{
    IRQ_NONE = 0(0 << 0),
    IRQ_HANDLE = (1 << 0),
    IRQ_WAKE_THREAD = (1 << 1)
};
åŒæ–‡ä»¶ä¸­è¿˜æœ‰ä¸ªå®å®šä¹‰ï¼š
#define IRQ_RETVAL(x) ((x) ? IRQ_HANDLED : IRQ_NONE)
æ‰€ä»¥ä¹Ÿå¯ä»¥ä½¿ç”¨æ­¤å®åšä¸ºè¿”å›å€¼ã€‚

3.flags:ä¸­æ–­æ ‡å¿—ï¼Œå°±æ˜¯æ ‡è®°ä»€ä¹ˆæƒ…å†µä¸‹å‘ç”Ÿçš„ä¸­æ–­ï¼ŒLinuxä¸­æä¾›äº†ç›¸åº”çš„æ ‡è®°:/include/linux/interrupt.hä¸‹å®šä¹‰
#define IRQF_TRIGGER_NONE Â  0x00000000
#define IRQF_TRIGGER_RISING 0x00000001  ä¸Šå‡æ²¿
#define IRQF_TRIGGER_FALLING Â  Â 0x00000002 ä¸‹é™æ²¿
#define IRQF_TRIGGER_HIGH Â  0x00000004 é«˜ç”µå¹³
#define IRQF_TRIGGER_LOW Â  Â 0x00000008 ä½ç”µå¹³
#define IRQF_TRIGGER_MASK Â  (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \
Â  Â  Â  Â  Â  Â  Â  Â  Â IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)
#define IRQF_TRIGGER_PROBE Â 0x00000010

4.name:ä¸­æ–­çš„åå­—ï¼Œåœ¨/proc/irqä¸‹å¯ä»¥çœ‹åˆ°ï¼Œç”±ç¨‹åºå‘˜å®šä¹‰
5.dev:ä¸­æ–­å‘ç”Ÿåè°ƒç”¨ä¸­æ–­å¤„ç†å‡½æ•°ä¼ é€’ç»™ä¸­æ–­å¤„ç†å‡½æ•°çš„å‚æ•°ã€‚å¦‚æœä¸­æ–­è®¾ç½®æ ‡å¿—ä¸ºå…±äº«ï¼ˆIRQF_SHAREDï¼‰çš„è¯ï¼Œæ­¤å‚æ•°ç”¨æ¥åŒºåˆ†å…·ä½“çš„ä¸­æ–­
å…±äº«ä¸­æ–­åªæœ‰åœ¨é‡Šæ”¾æœ€åä¸­æ–­å¤„ç†å‡½æ•°çš„æ—¶å€™æ‰ä¼šè¢«ç¦æ­¢æ‰ï¼Œå³ä¼ é€’å…·ä½“é‚£ä¸ªè®¾å¤‡çš„åœ°å€ï¼Œè¯´æ˜æ˜¯é‚£ä¸ªè®¾å¤‡å‘å‡ºçš„ä¸­æ–­ã€‚
è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›éé›¶é”™è¯¯ç ã€‚
```

å› ä¸ºISRä¸­æ–­å¤„ç†ä¾‹ç¨‹åœ¨æ‰§è¡Œå‰ç³»ç»Ÿä¸ºå…³é—­å½“å‰cpuçš„ä¸­æ–­ï¼Œæ‰€ä»¥åœ¨ISRæ‰§è¡Œæ—¶ï¼Œä¸å¯ä»¥æœ‰é˜»å¡çš„æ“ä½œã€‚æ‰§è¡Œå®æ—¶æ€§æ¯”è¾ƒé«˜çš„ä»»åŠ¡ï¼Œå¦‚æœä»»åŠ¡éœ€è¦å»¶è¿Ÿå¤„ç†ï¼Œåˆ™åº”è¯¥æ”¾åœ¨ä¸­æ–­çš„ä¸‹æ–‡taskletæˆ–workqueueä¸­æ‰§è¡Œã€‚

## 3.ä¸­æ–­åº”ç”¨ï¼šæŒ‰é”®ä¸­æ–­é©±åŠ¨å®ä¾‹ï¼š

```cpp
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/mod_devicetable.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/io.h>

#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <asm-generic/gpio.h>
#include <linux/of_platform.h>
#include <linux/interrupt.h>
#include <linux/of_irq.h>

struct MyLED{
Â  Â  //å‘ä¸Šæä¾›æ“ä½œæ¥å£çš„cdev
Â  Â  struct cdev* c_dev;
Â  Â  //åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„ï¼š
Â  Â  struct class* class;
Â  Â  struct device* dev;
Â  Â  //è®°å½•gpioèµ„æºçš„gpioå·ï¼š
Â  Â  u32 led1_gpios;
Â  Â  u32 led2_gpios;
Â  Â  u32 led3_gpios;
};

//å®šä¹‰ä¸€ä¸ªMyLedè®¾å¤‡å¯¹è±¡ï¼š
struct MyLED myled = {0};

int myled_open(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_open æ‰§è¡Œäº†\n");
Â  Â  return 0;
}
ssize_t myled_write(struct file *file, const char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  char k_buf[32] = {0};
Â  Â  printk("myled_write æ‰§è¡Œäº†\n");
Â  Â  copy_from_user(k_buf + *offset, usrbuf, size);

Â  Â  if(k_buf[0] == '1')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  }else if(k_buf[0] == '2')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  }else if(k_buf[0] == '3')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  }else{
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  }
Â  Â  return size;
}
ssize_t myled_read(struct file *file, char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  printk("myled_read æ‰§è¡Œäº†\n");
Â  Â  return size;
}

int myled_close(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_close æ‰§è¡Œäº†\n");
Â  Â  return 0;
}

struct file_operations fops = {
Â  Â  .open = myled_open,
Â  Â  .read = myled_read,
Â  Â  .write = myled_write,
Â  Â  .release = myled_close,
};

struct MyKey
{
Â  Â  u32 key1_interrupts;
Â  Â  u8 key1_status;
Â  Â  u32 key2_interrupts;
Â  Â  u8 key2_status;
Â  Â  u32 key3_interrupts;
Â  Â  u8 key3_status;
};
struct MyKey mykey = {0};
irqreturn_t key_ISR(int irq, void * dev)
{
Â  Â  if(irq == mykey.key1_interrupts)
Â  Â  {
Â  Â  Â  Â  if(!mykey.key1_status)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  Â  Â  Â  Â  mykey.key1_status = !mykey.key1_status;
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  Â  Â  mykey.key1_status = !mykey.key1_status;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(irq == mykey.key2_interrupts)
Â  Â  {
Â  Â  Â  Â  if(!mykey.key2_status)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  Â  Â  Â  Â  mykey.key2_status = !mykey.key2_status;
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  Â  Â  mykey.key2_status = !mykey.key2_status;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(irq == mykey.key3_interrupts)
Â  Â  {
Â  Â  Â  Â  if(!mykey.key3_status)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  Â  Â  Â  Â  mykey.key3_status = !mykey.key3_status;
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  Â  Â  Â  Â  mykey.key3_status = !mykey.key3_status;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  return IRQ_HANDLED;
}


int my_dev_driver_probe(struct platform_device *pdev)
{
Â  Â  struct device_node* key_node;
Â  Â  printk("my_dev_driver_probe probeå‡½æ•°æ‰§è¡Œ\n");
Â  Â  //1.å¯¹myledå¯¹è±¡ä¸­çš„å±æ€§è¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.c_dev = cdev_alloc();
Â  Â  cdev_init(myled.c_dev,&fops);
Â  Â  //ç”³è¯·è®¾å¤‡å·ï¼š
Â  Â  alloc_chrdev_region(&myled.c_dev->dev, 0, 1, "myled");
Â  Â  //æŠŠcdevæ”¾åœ¨å†…æ ¸ç®¡ç†é“¾è¡¨ä¸­ï¼š
Â  Â  cdev_add(myled.c_dev,myled.c_dev->dev,1);

Â  Â  //2.è‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼š
Â  Â  myled.class = class_create(THIS_MODULE,"MYLED");
Â  Â  myled.dev = device_create(myled.class,NULL, myled.c_dev->dev,NULL, pdev->name);
Â  Â  printk("æ–‡ä»¶å=%s\n",pdev->name);

Â  Â  //3.å¯¹gpioèµ„æºè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.led1_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",0);
Â  Â  gpio_request(myled.led1_gpios, "led1_gpios");
Â  Â  gpio_direction_output(myled.led1_gpios,0);
Â  Â  myled.led2_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",1);
Â  Â  gpio_request(myled.led2_gpios, "led2_gpios");
Â  Â  gpio_direction_output(myled.led2_gpios,0);
Â  Â  myled.led3_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",2);
Â  Â  gpio_request(myled.led3_gpios, "led3_gpios");
Â  Â  gpio_direction_output(myled.led3_gpios,0);


Â  Â  //è·å–keyè®¾å¤‡æ ‘è±¡èŠ‚ç‚¹çš„å¯¹è±¡æŒ‡é’ˆï¼š
Â  Â  key_node = of_find_node_by_path("/mykey");

Â  Â  //4.è·å–Keyå¯¹è±¡çš„linuxä¸­æ–­å·ï¼š
Â  Â  mykey.key1_interrupts = of_irq_get(key_node,0);
Â  Â  mykey.key2_interrupts = of_irq_get(key_node,1);
Â  Â  mykey.key3_interrupts = of_irq_get(key_node,2);

Â  Â  //5.è¯·æ±‚ä¸­æ–­å¹¶æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åºçš„å‡½æ•°;
Â  Â  request_irq(mykey.key1_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key2_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key3_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);

Â  Â  return 0;
}

int my_dev_driver_remove(struct platform_device *pdev)
{
Â  Â  printk("my_dev_driver_removerå‡½æ•°æ‰§è¡Œäº†\n");
Â  Â  gpio_free(myled.led3_gpios);
Â  Â  gpio_free(myled.led2_gpios);
Â  Â  gpio_free(myled.led1_gpios);
Â  Â  device_destroy(myled.class,myled.c_dev->dev);
Â  Â  class_destroy(myled.class);
Â  Â  cdev_del(myled.c_dev);
Â  Â  unregister_chrdev_region(myled.c_dev->dev,1);
Â  Â  kfree(myled.c_dev);
Â  Â  return 0;
}

struct platform_device_id id_table_match[] = {
Â  Â  [0] = {"WX,my_device_01", 1},
Â  Â  [1] = {"WX,my_device_02", 2},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

//è®¾å¤‡æ ‘åŒ¹é…æ–¹å¼ï¼š
struct of_device_id of_node_match_table[] = {
Â  Â  [0] = {.compatible = "WX,my_device_01"},
Â  Â  [1] = {.compatible = "WX,my_device_02"},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

// 1.å®šä¹‰ä¸€ä¸ªå¹³å°é©±åŠ¨å¯¹è±¡ï¼š
struct platform_driver my_platform_driver = {
Â  Â  .probe = my_dev_driver_probe,
Â  Â  .remove = my_dev_driver_remove,
Â  Â  .driver = {
Â  Â  Â  Â  .name = "WX,my_device_driver",
Â  Â  Â  Â  //è®¾å¤‡æ ‘çš„åŒ¹é…æ–¹å¼ï¼š
Â  Â  Â  Â  .of_match_table = of_node_match_table,
Â  Â  },
Â  Â  .id_table = id_table_match,
};

// å…¥å£å‡½æ•°ï¼š
int __init my_test_module_init(void)
{
Â  Â  int ret = 0;
Â  Â  ret = platform_driver_register(&my_platform_driver);
Â  Â  if (ret < 0)
Â  Â  {
Â  Â  Â  Â  return -1;
Â  Â  }
Â  Â  return 0;
}

// å‡ºå£å‡½æ•°ï¼š
void __exit my_test_module_exit(void)
{
Â  Â  platform_driver_unregister(&my_platform_driver);
}

// æŒ‡å®šè®¸å¯ï¼š
MODULE_LICENSE("GPL");
MODULE_AUTHOR("gaowanxi, email:gaonetcom@163.com");
// æŒ‡å®šå…¥å£åŠå‡ºå£å‡½æ•°ï¼š
module_init(my_test_module_init);
module_exit(my_test_module_exit);
```

## 4.æŒ‰é”®æŒ‰ä¸‹çš„æŠ–åŠ¨é—®é¢˜åŠè§£å†³æ–¹æ³•ï¼š

ç”±äºææ–™çš„ç‰©ç†ç‰¹æ€§åŠç”µå­¦ç‰¹æ€§ï¼Œå½“æŒ‰é”®æŒ‰ä¸‹çš„ç¬é—´ï¼Œä¼šçŸ­æ—¶é—´å‡ºç°ç”µå¹³çš„é«˜ä½å˜åŒ–ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š

![](images/WEBRESOURCE14985d957e030f832b1427e0dda09092image.png)

# ç¬¬å››èŠ‚ã€å†…æ ¸å®šæ—¶å™¨timer_list:

## 1. å…³äºå†…æ ¸å®šæ—¶å™¨çš„ä»‹ç»ï¼š

**Linux å†…æ ¸å®šæ—¶å™¨é‡‡ç”¨ç³»ç»Ÿæ—¶é’Ÿæ¥å®ç°ï¼Œä¸ç¡¬ä»¶å®šæ—¶å™¨åŠŸèƒ½ä¸€æ ·ï¼Œå½“è¶…æ—¶æ—¶é—´åˆ°äº†ä»¥åè®¾**

**ç½®çš„å®šæ—¶å¤„ç†å‡½æ•°å°±ä¼šæ‰§è¡Œã€‚å†…æ ¸å®šæ—¶å™¨ä¸éœ€è¦ä¸€å¤§å †å¯„å­˜å™¨çš„é…ç½®å·¥ä½œï¼Œå¹¶ä¸”å†…æ ¸å®šæ—¶å™¨æ‰§è¡Œå®Œè¶…æ—¶å¤„ç†å‡½æ•°ä»¥åå°±ä¼šè‡ªåŠ¨å…³é—­ã€‚è‹¥éœ€è¦å‘¨æœŸè¿è¡Œï¼Œåˆ™éœ€è¦åœ¨å¤„ç†å‡½æ•°ä¸­å†æ¬¡æ‰“å¼€å†…æ ¸å®šæ—¶å™¨ã€‚**

**å†…æ ¸å®šæ—¶å™¨çš„è¶…æ—¶ä¸­æ–­å¤„ç†å‡½æ•°æ˜¯åŸºäºä¸€ç§è½¯ä¸­æ–­å®ç°çš„ï¼Œå¤„ç†è¿‡ç¨‹ä¸­ä¸å¯ä»¥å‡ºç°é˜»å¡æ“ä½œã€‚**

**Linux å†…æ ¸ä½¿ç”¨ timer_list ç»“æ„ä½“è¡¨ç¤ºå†…æ ¸å®šæ—¶å™¨ï¼Œ timer_list å®šä¹‰åœ¨æ–‡ä»¶include/linux/timer.h ä¸­ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š**

### 1. å†…æ ¸å®šæ—¶å™¨çš„ç»“æ„ä½“å¯¹è±¡timer_listï¼š

```c
#include <linux/timer.h>
struct timer_list {
	    /*
	     * All fields that change during normal runtime grouped to the
	     * same cacheline
	     */
	    struct hlist_node	entry; //å†…æ ¸é“¾è¡¨èŠ‚ç‚¹
	    unsigned long		expires;//å®šæ—¶å™¨è¶…æ—¶æ—¶é—´ã€‚
	    void			(*function)(struct timer_list *); //å†…æ ¸å®šæ—¶å™¨å¤„ç†å‡½æ•°
	    u32			flags; //ä¸€èˆ¬å¡«å†™ä¸º0;
#ifdef CONFIG_LOCKDEP
	    struct lockdep_map	lockdep_map;
#endif
};
```

## 2.ä½¿ç”¨å†…æ ¸å®šæ—¶å™¨çš„API:

### 1. å®šæ—¶å™¨å¯¹è±¡çš„åˆå§‹åŒ–ï¼š

```c
struct timer_list mytimer;
//ç»™å®šå®šä¹‰æ—¶çš„è¶…æ—¶æ—¶é—´ï¼š
mytimer.expires = jiffies + xæ•°ã€‚ï¼ˆæˆ–ç›´æ¥ä½¿ç”¨å†…æ ¸ä¸­çš„HZå®æ¥è¡¨ç¤ºå†…æ ¸çš„é¢‘ç‡ï¼‰

void timer_setup(struct timer_list *timer, void (*callback)(struct timer_list *), unsigned int flags);
*struct timer_list timer: è¿™æ˜¯æŒ‡å‘è¦åˆå§‹åŒ–çš„å®šæ—¶å™¨ç»“æ„çš„æŒ‡é’ˆã€‚
void (*callback)(struct timer_list *): è¿™æ˜¯å®šæ—¶å™¨åˆ°æœŸæ—¶è¦è°ƒç”¨çš„å›è°ƒå‡½æ•°ã€‚è¯¥å›è°ƒå‡½æ•°æ¥å—ä¸€ä¸ªæŒ‡å‘ struct timer_list çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ã€‚
unsigned int flags: è¿™æ˜¯åˆå§‹åŒ–å®šæ—¶å™¨æ—¶çš„æ ‡å¿—ä½ï¼Œç›®å‰é€šå¸¸è®¾ä¸º 0ã€‚
å…³äºjiffiesèŠ‚æ‹æ•°ä»‹ç»ï¼š
jiffiesÂ çš„å•ä½æ˜¯â€œæ—¶é’ŸèŠ‚æ‹â€ï¼ˆtickï¼‰ï¼Œä½†å®ƒæ‰€ä»£è¡¨çš„å…·ä½“æ—¶é—´é•¿åº¦å–å†³äºå†…æ ¸é…ç½®ä¸­çš„Â CONFIG_HZÂ å€¼ã€‚CONFIG_HZÂ å®šä¹‰äº†ä¸€ç§’å†…çš„æ—¶é’ŸèŠ‚æ‹æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªæ—¶é’ŸèŠ‚æ‹çš„æ—¶é—´é•¿åº¦æ˜¯Â 1/CONFIG_HZÂ ç§’ã€‚
ä¾‹å¦‚ï¼š
å¦‚æœÂ CONFIG_HZÂ æ˜¯ 100ï¼Œé‚£ä¹ˆæ¯ä¸ªÂ jiffiesÂ å°±æ˜¯ 10 æ¯«ç§’ï¼ˆmsï¼‰ã€‚
å¦‚æœÂ CONFIG_HZÂ æ˜¯ 250ï¼Œé‚£ä¹ˆæ¯ä¸ªÂ jiffiesÂ å°±æ˜¯ 4 æ¯«ç§’ï¼ˆmsï¼‰ã€‚
```

### 2.å†…æ ¸å®šé‡Œå™¨çš„å¯åŠ¨æ–¹å¼ï¼šå†…æ ¸å®šæ—¶å™¨æ‰§è¡Œå®Œè¶…æ—¶å¤„ç†å‡½æ•°ä»¥åå°±ä¼šè‡ªåŠ¨å…³é—­ã€‚è‹¥éœ€è¦å‘¨æœŸè¿è¡Œï¼Œåˆ™éœ€è¦åœ¨å¤„ç†å‡½æ•°ä¸­ä½¿ç”¨mod_timerå†æ¬¡æ‰“å¼€å†…æ ¸å®šæ—¶å™¨ã€‚

```c
//æ·»åŠ å®šæ—¶å™¨åˆ°å†…æ ¸å®šæ—¶å™¨é“¾è¡¨ä¸­
void add_timer(struct timer_list* timer);å¯åŠ¨å®šæ—¶å™¨ï¼Œåƒä¸‡è¦æ³¨æ„ï¼Œå®šæ—¶å™¨åªèƒ½å¯åŠ¨ä¸€æ¬¡ï¼Œå¤šæ¬¡è°ƒç”¨ä¼šå‘ç”Ÿå´©æºƒã€‚
//ä¿®æ”¹å®šæ—¶å™¨ï¼š
int mod_timer(struct timer_list* timer, unsigned long expires);åœ¨å¤„ç†å‡½æ•°ä¸­å†æ¬¡å¯åŠ¨å®šæ—¶å™¨ã€‚
```

### 3.åˆ é™¤å®šæ—¶å™¨ï¼Œå½“å®šæ—¶å™¨ä¸å†ä½¿ç”¨æ—¶ï¼Œè®°å¾—åˆ é™¤å®šæ—¶å™¨ï¼š

```c
//ä»å†…æ ¸ä¸­çš„å®šæ—¶å™¨åˆ—è¡¨ä¸­åˆ é™¤ï¼Œä¸å†ä½¿ç”¨æ­¤å®šæ—¶å™¨æ—¶ä½¿ç”¨ã€‚
int del_timer(struct timer_list* timer);
```

## 3.å®šæ—¶å™¨æ¶ˆæŠ–åº”ç”¨ç¤ºä¾‹ï¼š

```cpp
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/mod_devicetable.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/io.h>

#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <asm-generic/gpio.h>
#include <linux/of_platform.h>
#include <linux/interrupt.h>
#include <linux/of_irq.h>
#include <linux/timer.h>
#include <linux/jiffies.h>

struct MyLED{
Â  Â  //å‘ä¸Šæä¾›æ“ä½œæ¥å£çš„cdev
Â  Â  struct cdev* c_dev;
Â  Â  //åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„ï¼š
Â  Â  struct class* class;
Â  Â  struct device* dev;
Â  Â  //è®°å½•gpioèµ„æºçš„gpioå·ï¼š
Â  Â  u32 led1_gpios;
Â  Â  u32 led2_gpios;
Â  Â  u32 led3_gpios;
};

//å®šä¹‰ä¸€ä¸ªMyLedè®¾å¤‡å¯¹è±¡ï¼š
struct MyLED myled = {0};

int myled_open(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_open æ‰§è¡Œäº†\n");
Â  Â  return 0;
}
ssize_t myled_write(struct file *file, const char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  char k_buf[32] = {0};
Â  Â  printk("myled_write æ‰§è¡Œäº†\n");
Â  Â  copy_from_user(k_buf + *offset, usrbuf, size);

Â  Â  if(k_buf[0] == '1')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  }else if(k_buf[0] == '2')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  }else if(k_buf[0] == '3')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  }else{
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  }
Â  Â  return size;
}
ssize_t myled_read(struct file *file, char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  printk("myled_read æ‰§è¡Œäº†\n");
Â  Â  return size;
}

int myled_close(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_close æ‰§è¡Œäº†\n");
Â  Â  return 0;
}

struct file_operations fops = {
Â  Â  .open = myled_open,
Â  Â  .read = myled_read,
Â  Â  .write = myled_write,
Â  Â  .release = myled_close,
};

struct MyKey
{
Â  Â  u32 key1_interrupts;
Â  Â  u8 key1_gpios;
Â  Â  u32 key2_interrupts;
Â  Â  u8 key2_gpios;
Â  Â  u32 key3_interrupts;
Â  Â  u8 key3_gpios;
Â  Â  //æ·»åŠ ä¸€ä¸ªå®šæ—¶å™¨ï¼š
Â  Â  struct timer_list timer;
Â  Â  //æ·»åŠ ä¸€ä¸‹irqå±æ€§ï¼š
Â  Â  volatile u32 irq;
};
struct MyKey mykey = {0};

void timerout_function(struct timer_list * timer)
{
Â  Â  if(mykey.irq == mykey.key1_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key1_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key2_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key2_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key3_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key3_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
}

irqreturn_t key_ISR(int irq, void * dev)
{
Â  Â  mykey.irq = irq;

Â  Â  //å¯åŠ¨å®šæ—¶å™¨ï¼š
Â  Â  mod_timer(&mykey.timer,mykey.timer.expires);
Â  Â  return IRQ_HANDLED;
}


int my_dev_driver_probe(struct platform_device *pdev)
{
Â  Â  struct device_node* key_node;
Â  Â  printk("my_dev_driver_probe probeå‡½æ•°æ‰§è¡Œ\n");
Â  Â  //1.å¯¹myledå¯¹è±¡ä¸­çš„å±æ€§è¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.c_dev = cdev_alloc();
Â  Â  cdev_init(myled.c_dev,&fops);
Â  Â  //ç”³è¯·è®¾å¤‡å·ï¼š
Â  Â  alloc_chrdev_region(&myled.c_dev->dev, 0, 1, "myled");
Â  Â  //æŠŠcdevæ”¾åœ¨å†…æ ¸ç®¡ç†é“¾è¡¨ä¸­ï¼š
Â  Â  cdev_add(myled.c_dev,myled.c_dev->dev,1);

Â  Â  //2.è‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼š
Â  Â  myled.class = class_create(THIS_MODULE,"MYLED");
Â  Â  myled.dev = device_create(myled.class,NULL, myled.c_dev->dev,NULL, pdev->name);
Â  Â  printk("æ–‡ä»¶å=%s\n",pdev->name);

Â  Â  //3.å¯¹gpioèµ„æºè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.led1_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",0);
Â  Â  gpio_request(myled.led1_gpios, "led1_gpios");
Â  Â  gpio_direction_output(myled.led1_gpios,0);
Â  Â  myled.led2_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",1);
Â  Â  gpio_request(myled.led2_gpios, "led2_gpios");
Â  Â  gpio_direction_output(myled.led2_gpios,0);
Â  Â  myled.led3_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",2);
Â  Â  gpio_request(myled.led3_gpios, "led3_gpios");
Â  Â  gpio_direction_output(myled.led3_gpios,0);


Â  Â  //è·å–keyè®¾å¤‡æ ‘è±¡èŠ‚ç‚¹çš„å¯¹è±¡æŒ‡é’ˆï¼š
Â  Â  key_node = of_find_node_by_path("/mykey");

Â  Â  //4.è·å–Keyå¯¹è±¡çš„linuxä¸­æ–­å·ï¼š
Â  Â  mykey.key1_interrupts = of_irq_get(key_node,0);
Â  Â  mykey.key1_gpios = of_get_named_gpio(key_node,"mykey_gpios",0);
Â  Â  gpio_direction_input(mykey.key1_gpios);
Â  Â  printk("irq = %d\n",mykey.key1_interrupts);
Â  Â  mykey.key2_interrupts = of_irq_get(key_node,1);
Â  Â  mykey.key2_gpios = of_get_named_gpio(key_node,"mykey_gpios",1);
Â  Â  gpio_direction_input(mykey.key2_gpios);
Â  Â  mykey.key3_interrupts = of_irq_get(key_node,2);
Â  Â  mykey.key3_gpios = of_get_named_gpio(key_node,"mykey_gpios",2);
Â  Â  gpio_direction_input(mykey.key3_gpios);

Â  Â  //5.è¯·æ±‚ä¸­æ–­å¹¶æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åºçš„å‡½æ•°;
Â  Â  request_irq(mykey.key1_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key2_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key3_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  

Â  Â  //6.å¯¹å®šä¹‰å™¨è¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  timer_setup(&mykey.timer,timerout_function,0);
Â  Â  mykey.timer.expires = jiffies + 10;
Â  Â  add_timer(&mykey.timer);

Â  Â  return 0;
}

int my_dev_driver_remove(struct platform_device *pdev)
{
Â  Â  printk("my_dev_driver_removerå‡½æ•°æ‰§è¡Œäº†\n");
    del_timer(&mykey.timer);
Â  Â  free_irq(mykey.key1_interrupts,NULL);
Â  Â  free_irq(mykey.key2_interrupts,NULL);
Â  Â  free_irq(mykey.key3_interrupts,NULL);
Â  Â  gpio_free(myled.led3_gpios);
Â  Â  gpio_free(myled.led2_gpios);
Â  Â  gpio_free(myled.led1_gpios);
Â  Â  device_destroy(myled.class,myled.c_dev->dev);
Â  Â  class_destroy(myled.class);
Â  Â  cdev_del(myled.c_dev);
Â  Â  unregister_chrdev_region(myled.c_dev->dev,1);
Â  Â  kfree(myled.c_dev);
Â  Â  return 0;
}

struct platform_device_id id_table_match[] = {
Â  Â  [0] = {"WX,my_device_01", 1},
Â  Â  [1] = {"WX,my_device_02", 2},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

//è®¾å¤‡æ ‘åŒ¹é…æ–¹å¼ï¼š
struct of_device_id of_node_match_table[] = {
Â  Â  [0] = {.compatible = "WX,my_device_01"},
Â  Â  [1] = {.compatible = "WX,my_device_02"},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};
  
// 1.å®šä¹‰ä¸€ä¸ªå¹³å°é©±åŠ¨å¯¹è±¡ï¼š
struct platform_driver my_platform_driver = {
Â  Â  .probe = my_dev_driver_probe,
Â  Â  .remove = my_dev_driver_remove,
Â  Â  .driver = {
Â  Â  Â  Â  .name = "WX,my_device_driver",
Â  Â  Â  Â  //è®¾å¤‡æ ‘çš„åŒ¹é…æ–¹å¼ï¼š
Â  Â  Â  Â  .of_match_table = of_node_match_table,
Â  Â  },
Â  Â  .id_table = id_table_match,
};

// å…¥å£å‡½æ•°ï¼š
int __init my_test_module_init(void)
{
Â  Â  int ret = 0;
Â  Â  ret = platform_driver_register(&my_platform_driver);
Â  Â  if (ret < 0)
Â  Â  {
Â  Â  Â  Â  return -1;
Â  Â  }
Â  Â  return 0;
}

// å‡ºå£å‡½æ•°ï¼š
void __exit my_test_module_exit(void)
{
Â  Â  platform_driver_unregister(&my_platform_driver);
}

// æŒ‡å®šè®¸å¯ï¼š
MODULE_LICENSE("GPL");
MODULE_AUTHOR("gaowanxi, email:gaonetcom@163.com");
// æŒ‡å®šå…¥å£åŠå‡ºå£å‡½æ•°ï¼š
module_init(my_test_module_init);
module_exit(my_test_module_exit);
```

# ç¬¬äº”èŠ‚ã€ä¸­æ–­ä¸‹æ–‡:tasklet

**æ‰€è°“æ˜¯ä¸­æ–­ä¸‹æ–‡å°±æ˜¯æŒ‡ï¼Œåœ¨ä¸­æ–­å¤„ç†ä¾‹ç¨‹ä¸­ä¸èƒ½é©¬ä¸Šè¿›è¡Œå¤„ç†å®Œæˆçš„ä»»åŠ¡ï¼Œéœ€è¦æ”¾åœ¨ä¸­æ–­ä¾‹ç¨‹æ‰§è¡Œç»“æŸåï¼Œè¿›è¡Œå»¶æ—¶å¤„ç†çš„ä¸­æ–­ä»»åŠ¡å°±æ˜¯ä¸­æ–­çš„ä¸‹æ–‡ã€‚**

**å¤„ç†ä¸­æ–­ä¸‹æ–‡çš„æ–¹å¼æœ‰ï¼š**

**1. è½¯ä¸­æ–­ï¼Œtasklet     ====>  **

**2.å·¥ä½œé˜Ÿåˆ—workqueue,  ä¸­æ–­çº¿ç¨‹åŒ–   ====>  å·¥ä½œé˜Ÿåˆ—workqueueä¸ä¸­æ–­çº¿ç¨‹åŒ–åœ¨å¤„ç†ä¸­æ–­ä¸‹æ–‡æ—¶å¯ä»¥å¤„ç†é˜»å¡çš„ä»»åŠ¡**

## 1.taskletåŠç›¸å…³APIï¼š

**ä¸€ç§è½¯ä¸­æ–­æœºåˆ¶, æ‰§è¡ŒæœŸé—´å…¶å®ƒè½¯ä¸­æ–­ä¸å¯æŠ¢å æ­¤ä¸­æ–­ï¼Œå¤„ç†ä¸€äº›ç®€å•çš„å»¶è¿Ÿä»»åŠ¡ã€‚è¿›ç¨‹ä¸å¯é˜»å¡ä¼‘çœ ã€‚å¾€å¾€åšä¸ºä¸­æ–­ä¸‹æ–¹ä¸­éœ€è¦åšç®€çŸ­å»¶æ—¶å¤„ç†ä»»åŠ¡æ—¶ä½¿ç”¨ã€‚**

### 1. åˆ†é…taskletå¯¹è±¡ï¼šstruct tasklet_struct ç»“æ„ä½“ï¼š

```c
struct tasklet_struct
{
	    struct tasklet_struct *next;//ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
	    unsigned long state;//taskletçš„çŠ¶æ€æ ‡è®°
	    atomic_t count;//taskletçš„å¼•ç”¨è®°æ•°
	    bool use_callback;//æ˜¯å¦ä½¿ç”¨å›è°ƒcallback;
	    union {
		    void (*func)(unsigned long data);//å›è°ƒfuncå‚æ•°data
		    void (*callback)(struct tasklet_struct *t);//å›è°ƒcallbackå‚æ•°ä¸ºtaskletå¯¹è±¡æŒ‡é’ˆã€‚
	    };
	    unsigned long data;//å‘funcå›è°ƒä¼ é€’çš„å‚æ•°ã€‚
};
```

### 2.åˆå§‹åŒ–taskletå¯¹è±¡apiï¼š

```c
//æ—§ç‰ˆæœ¬ï¼š
void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data);
//æ–°ç‰ˆæœ¬ï¼š
void tasklet_setup(struct tasklet_struct *t,void (*callback)(struct tasklet_struct *));
```

ä»¥ä¸Šä¸¤ä¸ªç‰ˆä¸­ï¼Œä¸€ä¸ªæ—§ç‰ˆä½¿ç”¨åŸfuncå›è°ƒï¼Œä¸€ä¸ªæ–°ç‰ˆï¼Œä½¿ç”¨callbackå›è°ƒã€‚ä»»å›é€‰æ‹©äº†ã€‚

### 3.è°ƒç”¨æ‰§è¡Œï¼štasklet_schedule();ä¸€èˆ¬æ”¾åœ¨é¡¶åŠéƒ¨çš„ä¸­æ–­å¤„ç†å‡½æ•°ä¸­ã€‚

```c
void tasklet_schedule(struct tasklet_struct *t);
```

### 4.æŠŠtaskletå¯¹è±¡ä»taskleté“¾è¡¨ä¸­åˆ é™¤ï¼š

```c
void tasklet_kill(struct tasklet_struct *t);
```

## 2.taskletçš„éé˜»å¡çš„mdelayæ¶ˆæŠ–åº”ç”¨ï¼š

```cpp
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/mod_devicetable.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/io.h>

#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <asm-generic/gpio.h>
#include <linux/of_platform.h>
#include <linux/interrupt.h>
#include <linux/of_irq.h>
#include <linux/timer.h>
#include <linux/jiffies.h>
#include <linux/delay.h>

struct MyLED{
Â  Â  //å‘ä¸Šæä¾›æ“ä½œæ¥å£çš„cdev
Â  Â  struct cdev* c_dev;
Â  Â  //åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„ï¼š
Â  Â  struct class* class;
Â  Â  struct device* dev;
Â  Â  //è®°å½•gpioèµ„æºçš„gpioå·ï¼š
Â  Â  u32 led1_gpios;
Â  Â  u32 led2_gpios;
Â  Â  u32 led3_gpios;

};

//å®šä¹‰ä¸€ä¸ªMyLedè®¾å¤‡å¯¹è±¡ï¼š
struct MyLED myled = {0};

int myled_open(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_open æ‰§è¡Œäº†\n");
Â  Â  return 0;
}
ssize_t myled_write(struct file *file, const char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  char k_buf[32] = {0};
Â  Â  printk("myled_write æ‰§è¡Œäº†\n");
Â  Â  copy_from_user(k_buf + *offset, usrbuf, size);

Â  Â  if(k_buf[0] == '1')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  }else if(k_buf[0] == '2')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  }else if(k_buf[0] == '3')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  }else{
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  }
Â  Â  return size;
}
ssize_t myled_read(struct file *file, char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  printk("myled_read æ‰§è¡Œäº†\n");
Â  Â  return size;
}

int myled_close(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_close æ‰§è¡Œäº†\n");
Â  Â  return 0;
}

struct file_operations fops = {
Â  Â  .open = myled_open,
Â  Â  .read = myled_read,
Â  Â  .write = myled_write,
Â  Â  .release = myled_close,
};

struct MyKey
{
Â  Â  u32 key1_interrupts;
Â  Â  u8 key1_gpios;
Â  Â  u32 key2_interrupts;
Â  Â  u8 key2_gpios;
Â  Â  u32 key3_interrupts;
Â  Â  u8 key3_gpios;
Â  Â  //æ·»åŠ ä¸€ä¸ªtaskletï¼š
Â  Â  struct tasklet_struct key_tasklet;
Â  Â  //æ·»åŠ ä¸€ä¸‹irqå±æ€§ï¼š
Â  Â  volatile u32 irq;
};
struct MyKey mykey = {0};

void tasklet_function(struct tasklet_struct * task)
{
Â  Â  mdelay(100);
Â  Â  if(mykey.irq == mykey.key1_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key1_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key2_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key2_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key3_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key3_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
}

irqreturn_t key_ISR(int irq, void * dev)
{
Â  Â  mykey.irq = irq;

Â  Â  //è°ƒç”¨taskletï¼š
Â  Â  tasklet_schedule(&mykey.key_tasklet);
Â  Â  return IRQ_HANDLED;
}


int my_dev_driver_probe(struct platform_device *pdev)
{
Â  Â  struct device_node* key_node;
Â  Â  printk("my_dev_driver_probe probeå‡½æ•°æ‰§è¡Œ\n");
Â  Â  //1.å¯¹myledå¯¹è±¡ä¸­çš„å±æ€§è¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.c_dev = cdev_alloc();
Â  Â  cdev_init(myled.c_dev,&fops);
Â  Â  //ç”³è¯·è®¾å¤‡å·ï¼š
Â  Â  alloc_chrdev_region(&myled.c_dev->dev, 0, 1, "myled");
Â  Â  //æŠŠcdevæ”¾åœ¨å†…æ ¸ç®¡ç†é“¾è¡¨ä¸­ï¼š
Â  Â  cdev_add(myled.c_dev,myled.c_dev->dev,1);

Â  Â  //2.è‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼š
Â  Â  myled.class = class_create(THIS_MODULE,"MYLED");
Â  Â  myled.dev = device_create(myled.class,NULL, myled.c_dev->dev,NULL, pdev->name);
Â  Â  printk("æ–‡ä»¶å=%s\n",pdev->name);

Â  Â  //3.å¯¹gpioèµ„æºè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.led1_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",0);
Â  Â  gpio_request(myled.led1_gpios, "led1_gpios");
Â  Â  gpio_direction_output(myled.led1_gpios,0);
Â  Â  myled.led2_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",1);
Â  Â  gpio_request(myled.led2_gpios, "led2_gpios");
Â  Â  gpio_direction_output(myled.led2_gpios,0);
Â  Â  myled.led3_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",2);
Â  Â  gpio_request(myled.led3_gpios, "led3_gpios");
Â  Â  gpio_direction_output(myled.led3_gpios,0);


Â  Â  //è·å–keyè®¾å¤‡æ ‘è±¡èŠ‚ç‚¹çš„å¯¹è±¡æŒ‡é’ˆï¼š
Â  Â  key_node = of_find_node_by_path("/mykey");

Â  Â  //4.è·å–Keyå¯¹è±¡çš„linuxä¸­æ–­å·ï¼š
Â  Â  mykey.key1_interrupts = of_irq_get(key_node,0);
Â  Â  mykey.key1_gpios = of_get_named_gpio(key_node,"mykey_gpios",0);
Â  Â  gpio_direction_input(mykey.key1_gpios);
Â  Â  printk("irq = %d\n",mykey.key1_interrupts);
Â  Â  printk("gpio = %d\n",mykey.key1_gpios);
Â  Â  mykey.key2_interrupts = of_irq_get(key_node,1);
Â  Â  mykey.key2_gpios = of_get_named_gpio(key_node,"mykey_gpios",1);
Â  Â  gpio_direction_input(mykey.key2_gpios);
Â  Â  mykey.key3_interrupts = of_irq_get(key_node,2);
Â  Â  mykey.key3_gpios = of_get_named_gpio(key_node,"mykey_gpios",2);
Â  Â  gpio_direction_input(mykey.key3_gpios);

Â  Â  //5.è¯·æ±‚ä¸­æ–­å¹¶æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åºçš„å‡½æ•°;
Â  Â  request_irq(mykey.key1_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key2_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key3_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  

Â  Â  //6.å¯¹taskletè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  tasklet_setup(&mykey.key_tasklet,tasklet_function);

Â  Â  return 0;
}

int my_dev_driver_remove(struct platform_device *pdev)
{
Â  Â  printk("my_dev_driver_removerå‡½æ•°æ‰§è¡Œäº†\n");
Â  Â  tasklet_kill(&mykey.key_tasklet);
Â  Â  free_irq(mykey.key1_interrupts,NULL);
Â  Â  free_irq(mykey.key2_interrupts,NULL);
Â  Â  free_irq(mykey.key3_interrupts,NULL);
Â  Â  gpio_free(myled.led3_gpios);
Â  Â  gpio_free(myled.led2_gpios);
Â  Â  gpio_free(myled.led1_gpios);
Â  Â  device_destroy(myled.class,myled.c_dev->dev);
Â  Â  class_destroy(myled.class);
Â  Â  cdev_del(myled.c_dev);
Â  Â  unregister_chrdev_region(myled.c_dev->dev,1);
Â  Â  kfree(myled.c_dev);
Â  Â  return 0;
}

struct platform_device_id id_table_match[] = {
Â  Â  [0] = {"WX,my_device_01", 1},
Â  Â  [1] = {"WX,my_device_02", 2},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

//è®¾å¤‡æ ‘åŒ¹é…æ–¹å¼ï¼š
struct of_device_id of_node_match_table[] = {
Â  Â  [0] = {.compatible = "WX,my_device_01"},
Â  Â  [1] = {.compatible = "WX,my_device_02"},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

// 1.å®šä¹‰ä¸€ä¸ªå¹³å°é©±åŠ¨å¯¹è±¡ï¼š
struct platform_driver my_platform_driver = {
Â  Â  .probe = my_dev_driver_probe,
Â  Â  .remove = my_dev_driver_remove,
Â  Â  .driver = {
Â  Â  Â  Â  .name = "WX,my_device_driver",
Â  Â  Â  Â  //è®¾å¤‡æ ‘çš„åŒ¹é…æ–¹å¼ï¼š
Â  Â  Â  Â  .of_match_table = of_node_match_table,
Â  Â  },
Â  Â  .id_table = id_table_match,
};

// å…¥å£å‡½æ•°ï¼š
int __init my_test_module_init(void)
{
Â  Â  int ret = 0;
Â  Â  ret = platform_driver_register(&my_platform_driver);
Â  Â  if (ret < 0)
Â  Â  {
Â  Â  Â  Â  return -1;
Â  Â  }
Â  Â  return 0;
}

// å‡ºå£å‡½æ•°ï¼š
void __exit my_test_module_exit(void)
{
Â  Â  platform_driver_unregister(&my_platform_driver);
}

// æŒ‡å®šè®¸å¯ï¼š
MODULE_LICENSE("GPL");
MODULE_AUTHOR("gaowanxi, email:gaonetcom@163.com");
// æŒ‡å®šå…¥å£åŠå‡ºå£å‡½æ•°ï¼š
module_init(my_test_module_init);
module_exit(my_test_module_exit);
```

# ç¬¬å…­èŠ‚ã€ä¸­æ–­ä¸‹æ–‡ï¼šå·¥ä½œé˜Ÿåˆ—workqueue

**ä¸€ç§workå†…æ ¸çº¿ç¨‹æœºåˆ¶ï¼Œæ‰§è¡Œæ›´å¤æ‚çš„å»¶è¿Ÿå¤„ç†çš„ä»»åŠ¡ã€‚è¿›ç¨‹å¯ä¼‘çœ ã€‚**

## 1.workqueueå·¥ä½œé˜Ÿåˆ—ç›¸å…³çš„APIä»‹ç»ï¼š

### 1.åˆ›å»ºå·¥ä½œï¼šå¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å·¥ä½œï¼Œä½†å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½¿ç”¨ç³»ç»Ÿæä¾›çš„é»˜è®¤å·¥ä½œé˜Ÿåˆ—å³å¯ã€‚

```cpp
#include <linux/workqueue.h>
struct work_struct {
    /*	atomic_long_t data; */
	    unsigned long data;
	    struct list_head entry;
	    work_func_t func; //å›è°ƒçš„é˜Ÿåˆ—çš„å¤„ç†å‡½æ•°
        //typedef void (*work_func_t)(struct work_struct *work);//å›è°ƒå‡½æ•°ç±»å‹
#ifdef CONFIG_LOCKDEP
	    struct lockdep_map lockdep_map;
#endif
};

```

### 2.åˆå§‹åŒ–å·¥ä½œï¼ˆstruct work_structï¼‰ï¼šå®šä¹‰ä¸€ä¸ªå·¥ä½œç»“æ„ï¼Œå¹¶æŒ‡å®šå…¶æ‰§è¡Œçš„å‡½æ•°ã€‚

```cpp
åˆ›å»ºå·¥ä½œworkçš„å®ï¼š_workæ˜¯ä¸€ä¸ªæŒ‡é’ˆ
ä½¿ç”¨INIT_WORK(_work,_func)æ¥è¿›è¡Œåˆå§‹åŒ–ã€‚
```

### 3.æäº¤å·¥ä½œï¼šå°†å·¥ä½œæäº¤åˆ°å·¥ä½œé˜Ÿåˆ—ï¼Œä»¥ä¾¿ç¨åæ‰§è¡Œã€‚

```cpp
bool schedule_work(struct work_struct *work);
è¿”å›å€¼ï¼šæˆåŠŸå°†å·¥ä½œæ·»åŠ åˆ°é»˜è®¤é˜Ÿåˆ—ä¸­ï¼Œè¿”å›true,å¤±è´¥è¿”å›false.
```

### 4.å–æ¶ˆå·¥ä½œï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯ä»¥å–æ¶ˆå·²ç»æäº¤ä½†å°šæœªæ‰§è¡Œçš„å·¥ä½œã€‚

```cpp
//å»¶æ—¶å¸è½½ï¼š
void cancel_work_sync(struct work_struct *work);
å¦‚æœå¸è½½æ¨¡å—æ—¶ï¼Œä¸‡ä¸€æœ‰å·¥ä½œé˜Ÿåˆ—ä¸­ä»»åŠ¡è¿˜æ²¡æœ‰æ‰§è¡Œç»“æŸï¼Œä½¿ç”¨æ­¤æ–¹æ³•ï¼Œå¯ä»¥ç­‰å¾…ä»»åŠ¡æ‰§è¡Œç»“æŸåå†å¸è½½ã€‚

void destroy_workqueue(struct workqueue_struct *wq);
//æ¶ˆæ¯å½“å‰å·¥ä½œé˜Ÿåˆ—ã€‚ä¸€èˆ¬ä¼šå…ˆå–æ¶ˆå·¥ä½œï¼Œå†é”€æ¯é˜Ÿåˆ—ï¼Œå¦‚æœæ‰‹åŠ¨ç”³è¯·äº†æŒ‡å®šçš„å·¥ä½œé˜Ÿåˆ—ã€‚
```

## 2.workqueueçš„é˜»å¡çš„msleepæ¶ˆæŠ–åº”ç”¨ï¼š

```cpp
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/mod_devicetable.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/io.h>

#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <asm-generic/gpio.h>
#include <linux/of_platform.h>
#include <linux/interrupt.h>
#include <linux/of_irq.h>
#include <linux/timer.h>
#include <linux/jiffies.h>
#include <linux/delay.h>
#include <linux/workqueue.h>

struct MyLED{
Â  Â  //å‘ä¸Šæä¾›æ“ä½œæ¥å£çš„cdev
Â  Â  struct cdev* c_dev;
Â  Â  //åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„ï¼š
Â  Â  struct class* class;
Â  Â  struct device* dev;
Â  Â  //è®°å½•gpioèµ„æºçš„gpioå·ï¼š
Â  Â  u32 led1_gpios;
Â  Â  u32 led2_gpios;
Â  Â  u32 led3_gpios;

};

//å®šä¹‰ä¸€ä¸ªMyLedè®¾å¤‡å¯¹è±¡ï¼š
struct MyLED myled = {0};

int myled_open(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_open æ‰§è¡Œäº†\n");
Â  Â  return 0;
}
ssize_t myled_write(struct file *file, const char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  char k_buf[32] = {0};
Â  Â  printk("myled_write æ‰§è¡Œäº†\n");
Â  Â  copy_from_user(k_buf + *offset, usrbuf, size);

Â  Â  if(k_buf[0] == '1')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  }else if(k_buf[0] == '2')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  }else if(k_buf[0] == '3')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  }else{
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  }
Â  Â  return size;
}
ssize_t myled_read(struct file *file, char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  printk("myled_read æ‰§è¡Œäº†\n");
Â  Â  return size;
}

int myled_close(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_close æ‰§è¡Œäº†\n");
Â  Â  return 0;
}

struct file_operations fops = {
Â  Â  .open = myled_open,
Â  Â  .read = myled_read,
Â  Â  .write = myled_write,
Â  Â  .release = myled_close,
};

struct MyKey
{
Â  Â  u32 key1_interrupts;
Â  Â  u8 key1_gpios;
Â  Â  u32 key2_interrupts;
Â  Â  u8 key2_gpios;
Â  Â  u32 key3_interrupts;
Â  Â  u8 key3_gpios;
Â  Â  //æ·»åŠ ä¸€ä¸ªå·¥ä½œé˜Ÿåˆ—ï¼šworkqueueï¼š
Â  Â  struct work_struct work;
Â  Â  //æ·»åŠ ä¸€ä¸‹irqå±æ€§ï¼š
Â  Â  volatile u32 irq;
};
struct MyKey mykey = {0};

Â void work_functions(struct work_struct *work)
{
Â  Â  //mdelay(100);
Â  Â  //é˜»å¡å¼å»¶æ—¶å‡½æ•°ï¼š
Â  Â  msleep(50);
Â  Â  if(mykey.irq == mykey.key1_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key1_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key2_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key2_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key3_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key3_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
}

irqreturn_t key_ISR(int irq, void * dev)
{
Â  Â  mykey.irq = irq;

Â  Â  //è°ƒç”¨å·¥ä½œworkï¼š
Â  Â  schedule_work(&mykey.work);
Â  Â  return IRQ_HANDLED;
}


int my_dev_driver_probe(struct platform_device *pdev)
{
Â  Â  struct device_node* key_node;
Â  Â  printk("my_dev_driver_probe probeå‡½æ•°æ‰§è¡Œ\n");
Â  Â  //1.å¯¹myledå¯¹è±¡ä¸­çš„å±æ€§è¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.c_dev = cdev_alloc();
Â  Â  cdev_init(myled.c_dev,&fops);
Â  Â  //ç”³è¯·è®¾å¤‡å·ï¼š
Â  Â  alloc_chrdev_region(&myled.c_dev->dev, 0, 1, "myled");
Â  Â  //æŠŠcdevæ”¾åœ¨å†…æ ¸ç®¡ç†é“¾è¡¨ä¸­ï¼š
Â  Â  cdev_add(myled.c_dev,myled.c_dev->dev,1);

Â  Â  //2.è‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼š
Â  Â  myled.class = class_create(THIS_MODULE,"MYLED");
Â  Â  myled.dev = device_create(myled.class,NULL, myled.c_dev->dev,NULL, pdev->name);
Â  Â  printk("æ–‡ä»¶å=%s\n",pdev->name);

Â  Â  //3.å¯¹gpioèµ„æºè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.led1_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",0);
Â  Â  gpio_request(myled.led1_gpios, "led1_gpios");
Â  Â  gpio_direction_output(myled.led1_gpios,0);
Â  Â  myled.led2_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",1);
Â  Â  gpio_request(myled.led2_gpios, "led2_gpios");
Â  Â  gpio_direction_output(myled.led2_gpios,0);
Â  Â  myled.led3_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",2);
Â  Â  gpio_request(myled.led3_gpios, "led3_gpios");
Â  Â  gpio_direction_output(myled.led3_gpios,0);


Â  Â  //è·å–keyè®¾å¤‡æ ‘è±¡èŠ‚ç‚¹çš„å¯¹è±¡æŒ‡é’ˆï¼š
Â  Â  key_node = of_find_node_by_path("/mykey");

Â  Â  //4.è·å–Keyå¯¹è±¡çš„linuxä¸­æ–­å·ï¼š
Â  Â  mykey.key1_interrupts = of_irq_get(key_node,0);
Â  Â  mykey.key1_gpios = of_get_named_gpio(key_node,"mykey_gpios",0);
Â  Â  gpio_direction_input(mykey.key1_gpios);
Â  Â  printk("irq = %d\n",mykey.key1_interrupts);
Â  Â  printk("gpio = %d\n",mykey.key1_gpios);
Â  Â  mykey.key2_interrupts = of_irq_get(key_node,1);
Â  Â  mykey.key2_gpios = of_get_named_gpio(key_node,"mykey_gpios",1);
Â  Â  gpio_direction_input(mykey.key2_gpios);
Â  Â  mykey.key3_interrupts = of_irq_get(key_node,2);
Â  Â  mykey.key3_gpios = of_get_named_gpio(key_node,"mykey_gpios",2);
Â  Â  gpio_direction_input(mykey.key3_gpios);

Â  Â  //5.è¯·æ±‚ä¸­æ–­å¹¶æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åºçš„å‡½æ•°;
Â  Â  request_irq(mykey.key1_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key2_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  request_irq(mykey.key3_interrupts,key_ISR,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key-interrupts",NULL);
Â  Â  

Â  Â  //6.å¯¹å·¥ä½œè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  INIT_WORK(&mykey.work, work_functions);

Â  Â  return 0;
}

int my_dev_driver_remove(struct platform_device *pdev)
{
Â  Â  printk("my_dev_driver_removerå‡½æ•°æ‰§è¡Œäº†\n");
Â  Â  //tasklet_kill(&mykey.key_tasklet);
    //å–æ¶ˆå½“å‰å·¥ä½œ
Â  Â  cancel_work_sync(&mykey.work);
Â  Â  free_irq(mykey.key1_interrupts,NULL);
Â  Â  free_irq(mykey.key2_interrupts,NULL);
Â  Â  free_irq(mykey.key3_interrupts,NULL);
Â  Â  gpio_free(myled.led3_gpios);
Â  Â  gpio_free(myled.led2_gpios);
Â  Â  gpio_free(myled.led1_gpios);
Â  Â  device_destroy(myled.class,myled.c_dev->dev);
Â  Â  class_destroy(myled.class);
Â  Â  cdev_del(myled.c_dev);
Â  Â  unregister_chrdev_region(myled.c_dev->dev,1);
Â  Â  kfree(myled.c_dev);
Â  Â  return 0;
}

struct platform_device_id id_table_match[] = {
Â  Â  [0] = {"WX,my_device_01", 1},
Â  Â  [1] = {"WX,my_device_02", 2},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

//è®¾å¤‡æ ‘åŒ¹é…æ–¹å¼ï¼š
struct of_device_id of_node_match_table[] = {
Â  Â  [0] = {.compatible = "WX,my_device_01"},
Â  Â  [1] = {.compatible = "WX,my_device_02"},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

// 1.å®šä¹‰ä¸€ä¸ªå¹³å°é©±åŠ¨å¯¹è±¡ï¼š
struct platform_driver my_platform_driver = {
Â  Â  .probe = my_dev_driver_probe,
Â  Â  .remove = my_dev_driver_remove,
Â  Â  .driver = {
Â  Â  Â  Â  .name = "WX,my_device_driver",
Â  Â  Â  Â  //è®¾å¤‡æ ‘çš„åŒ¹é…æ–¹å¼ï¼š
Â  Â  Â  Â  .of_match_table = of_node_match_table,
Â  Â  },
Â  Â  .id_table = id_table_match,
};

// å…¥å£å‡½æ•°ï¼š
int __init my_test_module_init(void)
{
Â  Â  int ret = 0;
Â  Â  ret = platform_driver_register(&my_platform_driver);
Â  Â  if (ret < 0)
Â  Â  {
Â  Â  Â  Â  return -1;
Â  Â  }
Â  Â  return 0;
}

// å‡ºå£å‡½æ•°ï¼š
void __exit my_test_module_exit(void)
{
Â  Â  platform_driver_unregister(&my_platform_driver);
}

// æŒ‡å®šè®¸å¯ï¼š
MODULE_LICENSE("GPL");
MODULE_AUTHOR("gaowanxi, email:gaonetcom@163.com");
// æŒ‡å®šå…¥å£åŠå‡ºå£å‡½æ•°ï¼š
module_init(my_test_module_init);
module_exit(my_test_module_exit);
```

# ç¬¬ä¸ƒèŠ‚ã€ä¸­æ–­ä¸‹æ–‡ï¼šä¸­æ–­çº¿ç¨‹åŒ–**request_threaded_irqå‡½æ•°çš„ä½¿ç”¨ï¼š**

**æŠ›å‡ºä¸€ä¸ªé—®é¢˜ï¼š**

![](images/WEBRESOURCEf9e499c10485fd8c4cc4fa37c9bd1bebimage.png)

## 1. **ä¸­æ–­çº¿ç¨‹åŒ–request_threaded_irqå‡½æ•°ä»‹ç»ï¼š**

```cpp
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id)
åŠŸèƒ½ï¼šåœ¨å¤šä¸ªå†…æ ¸çº¿ç¨‹ä¸­æ‰§è¡Œç›¸åº”çš„ä¸­æ–­ä¸‹æ–‡ä¸‹æ‰§è¡Œã€‚å¯ä»¥é˜»å¡çš„æ“ä½œã€‚
æˆåŠŸï¼šè¿”å›0ï¼Œå¤±è´¥è¿”å›é”™è¯¯ç 
```

**æ¡ä»¶ï¼šéœ€è¦åœ¨é¡¶åŠéƒ¨å¤„ç†ç¨‹åºä¸­é€šçŸ¥å†…æ ¸è¯¥ä¸­æ–­åº”ç”±çº¿ç¨‹åŒ–å¤„ç†ç¨‹åºå¤„ç†ï¼Œåœ¨é¡¶åŠéƒ¨è¿”å›**

**ä¸ºæ¯ä¸€ä¸ªä¸­æ–­å¤„ç†åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„å†…æ ¸çº¿ç¨‹æ‰§è¡Œã€‚å¯¹äºå¤šæ ¸CPUä¸Šçš„å¤„ç†ä¸­æ–­æ›´åŠ é«˜æ•ˆï¼Œæ›´æœ‰æ„ä¹‰ã€‚å¯ä»¥æœ‰é˜»å¡æ“ä½œã€‚**

## 2.ä¸­çº¿çº¿ç¨‹åŒ–é˜»å¡msleepæ¶ˆæŠ–å®éªŒç¤ºä¾‹ï¼š

```cpp
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/mod_devicetable.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/io.h>

#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <asm-generic/gpio.h>
#include <linux/of_platform.h>
#include <linux/interrupt.h>
#include <linux/of_irq.h>
#include <linux/timer.h>
#include <linux/jiffies.h>
#include <linux/delay.h>
#include <linux/workqueue.h>

struct MyLED{
Â  Â  //å‘ä¸Šæä¾›æ“ä½œæ¥å£çš„cdev
Â  Â  struct cdev* c_dev;
Â  Â  //åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„ï¼š
Â  Â  struct class* class;
Â  Â  struct device* dev;
Â  Â  //è®°å½•gpioèµ„æºçš„gpioå·ï¼š
Â  Â  u32 led1_gpios;
Â  Â  u32 led2_gpios;
Â  Â  u32 led3_gpios;

};

//å®šä¹‰ä¸€ä¸ªMyLedè®¾å¤‡å¯¹è±¡ï¼š
struct MyLED myled = {0};

int myled_open(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_open æ‰§è¡Œäº†\n");
Â  Â  return 0;
}
ssize_t myled_write(struct file *file, const char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  char k_buf[32] = {0};
Â  Â  printk("myled_write æ‰§è¡Œäº†\n");
Â  Â  copy_from_user(k_buf + *offset, usrbuf, size);

Â  Â  if(k_buf[0] == '1')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  }else if(k_buf[0] == '2')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  }else if(k_buf[0] == '3')
Â  Â  {
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  }else{
Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  }
Â  Â  return size;
}
ssize_t myled_read(struct file *file, char *usrbuf, size_t size, loff_t *offset)
{
Â  Â  printk("myled_read æ‰§è¡Œäº†\n");
Â  Â  return size;
}

int myled_close(struct inode *inode, struct file *file)
{
Â  Â  printk("myled_close æ‰§è¡Œäº†\n");
Â  Â  return 0;
}

struct file_operations fops = {
Â  Â  .open = myled_open,
Â  Â  .read = myled_read,
Â  Â  .write = myled_write,
Â  Â  .release = myled_close,
};

struct MyKey
{
Â  Â  u32 key1_interrupts;
Â  Â  u8 key1_gpios;
Â  Â  u32 key2_interrupts;
Â  Â  u8 key2_gpios;
Â  Â  u32 key3_interrupts;
Â  Â  u8 key3_gpios;
Â  Â  //æ·»åŠ ä¸€ä¸‹irqå±æ€§ï¼š
Â  Â  volatile u32 irq;
};
struct MyKey mykey = {0};

irqreturn_t threaded_irq_functions(int irq, void *dev)
{
Â  Â  //mdelay(100);
Â  Â  //é˜»å¡å¼å»¶æ—¶å‡½æ•°ï¼š
Â  Â  msleep(50);
Â  Â  if(mykey.irq == mykey.key1_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key1_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led1_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key2_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key2_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led2_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(mykey.irq == mykey.key3_interrupts)
Â  Â  {
Â  Â  Â  Â  if(gpio_get_value(mykey.key3_gpios) == 0)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  //key1æŒ‰ä¸‹äº†ï¼šå¼€1ç¯
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  //key1æŠ¬èµ·äº†ï¼šå…³1ç¯ï¼š
Â  Â  Â  Â  Â  Â  gpio_set_value(myled.led3_gpios, 0);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  return IRQ_HANDLED;
}

irqreturn_t key_ISR(int irq, void * dev)
{
Â  Â  mykey.irq = irq;
Â  Â  return IRQ_WAKE_THREAD;
}


int my_dev_driver_probe(struct platform_device *pdev)
{
Â  Â  struct device_node* key_node;
Â  Â  printk("my_dev_driver_probe probeå‡½æ•°æ‰§è¡Œ\n");
Â  Â  //1.å¯¹myledå¯¹è±¡ä¸­çš„å±æ€§è¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.c_dev = cdev_alloc();
Â  Â  cdev_init(myled.c_dev,&fops);
Â  Â  //ç”³è¯·è®¾å¤‡å·ï¼š
Â  Â  alloc_chrdev_region(&myled.c_dev->dev, 0, 1, "myled");
Â  Â  //æŠŠcdevæ”¾åœ¨å†…æ ¸ç®¡ç†é“¾è¡¨ä¸­ï¼š
Â  Â  cdev_add(myled.c_dev,myled.c_dev->dev,1);

Â  Â  //2.è‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼š
Â  Â  myled.class = class_create(THIS_MODULE,"MYLED");
Â  Â  myled.dev = device_create(myled.class,NULL, myled.c_dev->dev,NULL, pdev->name);
Â  Â  printk("æ–‡ä»¶å=%s\n",pdev->name);

Â  Â  //3.å¯¹gpioèµ„æºè¿›è¡Œåˆå§‹åŒ–ï¼š
Â  Â  myled.led1_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",0);
Â  Â  gpio_request(myled.led1_gpios, "led1_gpios");
Â  Â  gpio_direction_output(myled.led1_gpios,0);
Â  Â  myled.led2_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",1);
Â  Â  gpio_request(myled.led2_gpios, "led2_gpios");
Â  Â  gpio_direction_output(myled.led2_gpios,0);
Â  Â  myled.led3_gpios = of_get_named_gpio(pdev->dev.of_node,"myled_gpios",2);
Â  Â  gpio_request(myled.led3_gpios, "led3_gpios");
Â  Â  gpio_direction_output(myled.led3_gpios,0);


Â  Â  //è·å–keyè®¾å¤‡æ ‘è±¡èŠ‚ç‚¹çš„å¯¹è±¡æŒ‡é’ˆï¼š
Â  Â  key_node = of_find_node_by_path("/mykey");

Â  Â  //4.è·å–Keyå¯¹è±¡çš„linuxä¸­æ–­å·ï¼š
Â  Â  mykey.key1_interrupts = of_irq_get(key_node,0);
Â  Â  mykey.key1_gpios = of_get_named_gpio(key_node,"mykey_gpios",0);
Â  Â  gpio_direction_input(mykey.key1_gpios);
Â  Â  printk("irq = %d\n",mykey.key1_interrupts);
Â  Â  printk("gpio = %d\n",mykey.key1_gpios);
Â  Â  mykey.key2_interrupts = of_irq_get(key_node,1);
Â  Â  mykey.key2_gpios = of_get_named_gpio(key_node,"mykey_gpios",1);
Â  Â  gpio_direction_input(mykey.key2_gpios);
Â  Â  mykey.key3_interrupts = of_irq_get(key_node,2);
Â  Â  mykey.key3_gpios = of_get_named_gpio(key_node,"mykey_gpios",2);
Â  Â  gpio_direction_input(mykey.key3_gpios);

Â  Â  //5.è¯·æ±‚ä¸­æ–­å¹¶æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åºçš„å‡½æ•°;
Â  Â  request_threaded_irq(mykey.key1_interrupts,key_ISR,threaded_irq_functions,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key1-interrupts",NULL);
Â  Â  request_threaded_irq(mykey.key2_interrupts,key_ISR,threaded_irq_functions,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key2-interrupts",NULL);
Â  Â  request_threaded_irq(mykey.key3_interrupts,key_ISR,threaded_irq_functions,IRQF_TRIGGER_RISING | IRQF_TRIGGER_RISING,"key3-interrupts",NULL);
Â  Â  //....


Â  Â  return 0;
}

int my_dev_driver_remove(struct platform_device *pdev)
{
Â  Â  printk("my_dev_driver_removerå‡½æ•°æ‰§è¡Œäº†\n");
Â  Â  free_irq(mykey.key1_interrupts,NULL);
Â  Â  free_irq(mykey.key2_interrupts,NULL);
Â  Â  free_irq(mykey.key3_interrupts,NULL);
Â  Â  gpio_free(myled.led3_gpios);
Â  Â  gpio_free(myled.led2_gpios);
Â  Â  gpio_free(myled.led1_gpios);
Â  Â  device_destroy(myled.class,myled.c_dev->dev);
Â  Â  class_destroy(myled.class);
Â  Â  cdev_del(myled.c_dev);
Â  Â  unregister_chrdev_region(myled.c_dev->dev,1);
Â  Â  kfree(myled.c_dev);
Â  Â  return 0;
}

struct platform_device_id id_table_match[] = {
Â  Â  [0] = {"WX,my_device_01", 1},
Â  Â  [1] = {"WX,my_device_02", 2},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

//è®¾å¤‡æ ‘åŒ¹é…æ–¹å¼ï¼š
struct of_device_id of_node_match_table[] = {
Â  Â  [0] = {.compatible = "WX,my_device_01"},
Â  Â  [1] = {.compatible = "WX,my_device_02"},
Â  Â  [2] = {/*æœ€åä¸€ä¸ªä¸€å®šè¦ç»™ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä»£è¡¨ç»“æŸ*/}
};

// 1.å®šä¹‰ä¸€ä¸ªå¹³å°é©±åŠ¨å¯¹è±¡ï¼š
struct platform_driver my_platform_driver = {
Â  Â  .probe = my_dev_driver_probe,
Â  Â  .remove = my_dev_driver_remove,
Â  Â  .driver = {
Â  Â  Â  Â  .name = "WX,my_device_driver",
Â  Â  Â  Â  //è®¾å¤‡æ ‘çš„åŒ¹é…æ–¹å¼ï¼š
Â  Â  Â  Â  .of_match_table = of_node_match_table,
Â  Â  },
Â  Â  .id_table = id_table_match,
};

// å…¥å£å‡½æ•°ï¼š
int __init my_test_module_init(void)
{
Â  Â  int ret = 0;
Â  Â  ret = platform_driver_register(&my_platform_driver);
Â  Â  if (ret < 0)
Â  Â  {
Â  Â  Â  Â  return -1;
Â  Â  }
Â  Â  return 0;
}

// å‡ºå£å‡½æ•°ï¼š
void __exit my_test_module_exit(void)
{
Â  Â  platform_driver_unregister(&my_platform_driver);
}

// æŒ‡å®šè®¸å¯ï¼š
MODULE_LICENSE("GPL");
MODULE_AUTHOR("gaowanxi, email:gaonetcom@163.com");
// æŒ‡å®šå…¥å£åŠå‡ºå£å‡½æ•°ï¼š
module_init(my_test_module_init);
module_exit(my_test_module_exit);
```

# ç¬¬å…«èŠ‚ï¼šæœ¬ç« æ€»ç»“ï¼š     

![](images/WEBRESOURCE7b93b7c8a7ef3bb8988322b6f730c9bfä¸­æ–­.jpg)