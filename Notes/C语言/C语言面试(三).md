# C 语言面试(三)

## **1. (内存)堆和栈的区别**⭐

**堆栈空间分配不同：**

- 栈由操作系统**自动**进行分配和释放，用于存放函数的参数值、局部变量的值等，具有高效性。
- 堆一般由程序员**手动**进行分配和释放，效率比栈低很多。

**堆栈缓存方式不同：**

- 栈使用**一级缓存**，**存储在处理器核心中**，调用完成后立即释放，速度较**快**。
- 堆存储在**二级缓存或主存**中，速度相对较**慢**。

**生长方向**：

- 栈：栈的分配方向是**向下**的，即向地址较小的方向分配。当栈需要扩展时，会向**低地址方向增长**。
- 堆：堆的分配方向是**向上**的，即向地址较大的方向分配。当堆需要扩展时，会向**高地址方向增长**。

**生命周期：**

- 栈：栈上的内存分配和释放是自动进行的，随着函数的调用和返回进行相应的操作。**栈上的数据只在特定的作用域内有效，函数执行完成后会自动释放。**
- 堆：堆上的内存在分配时并不会被立即释放，需要手动进行内存释放操作。**堆上的数据可以在程序的任意位置进行访问，不受函数的调用关系限制。**

**空间大小：**

- 栈的空间大小**一般较小**，通常最多为 2 MB，超过则会报溢出错误。
- 堆的空间**比较大**，理论上可以接近 3 GB（对于 32 位程序来说）。

**能否产生碎片：**

- 栈操作遵循"后进先出"的原则，不会有内存块从栈中弹出，因此**不会产生碎片**。
- 堆是通过动态分配内存的方式进行分配和释放**，频繁的申请和释放内存可能会引发内存碎片问题**。

## **2. 在函数中申请堆内存需要注意什么**⭐

- 确保不要错误地返回指向栈内存的指针，因为栈内存会在函数结束时自动释放。
- 避免在函数内部申请临时数组，因为函数执行完成后，该数组会消失。
- 不要返回指向常量区的内存空间，因为它们无法修改且获取它们没有意义。
- 使用传入一级指针无法解决问题，因为函数内部指针的修改不会影响传入的指针。
- 在分配堆内存时，**确保空间足够存储所需数据**，避免访问越界和产生未定义行为。

解决办法如下：

- 使用二级指针来返回申请的堆内存的地址，通过间接引用来修改指针值，从而确保在函数外部能够获取到堆内存的内容。
  - 使用指针函数来解决问题，即返回通过 malloc 函数申请的堆内存的地址，这样可以在函数外部使用 free 函数释放该内存。

## 3. 请你说说内存碎片⭐

内存碎片是指在内存管理过程中产生的未被有效利用的零散、不连续的内存空间。主要分为两种类型：**内部碎片**和**外部碎片**。

- 内部碎片：**是由于固定大小的内存分配方式或对齐要求等原因导致的未被利用的小空间**。当分配给进程的内存块大于所需的大小时，其中的剩余空间就成为了内部碎片。
- 外部碎片：**是由于存在未分配的连续内存空间太小而不能满足分配请求**，从而导致这些内存无法被有效利用。

解决内存碎片问题的方法可以包括：

- 段页式管理：采用虚拟内存管理技术，将物理内存划分为不同的页或段，以更灵活地管理和分配内存空间，减少碎片化。
- 使用内存池：通过分配一定数量的内存块，由内存池来管理分配和回收，减少频繁的内存分配和释放，从而减少碎片化。

## 4. 什么是内存池⭐

**内存池（Memory Pool）**是一种动态内存分配与管理技术。通常情况下习惯使用 new/delete/malloc/free 等 API 申请分配和释放内存，这样导致的后果是：当程序长时间运行时，由于所申请的内存块大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。**内存池则是在真正使用内存之前，先申请分配一大块内存(内存池)留作备用，当我们申请内存时，从池中取出一块动态分配的内存，释放内存时，再将我们使用的内存释放到我们申请的内存池内，再次申请内存池也可以再取出来使用。并且，尽量与周边的内存块合并。若内存池不够时，则自动扩大内存池，从操作系统中申请更大的内存池**

### 为什么需要内存池？

**解决内存碎片问题**

![img](C语言面试(三)/D2B5CA33BD970F64A6301FA75AE2EB22.png)

假设系统依次分配了 16,16,4,8,8 字节，接着释放了 16 字节和 8 字节归还给了系统（红色表示还未归还给系统），那么现在堆区空闲了一个 16 字节的空间和一个 8 字节的空间。这时如果用户要想申请出一个 24 字节的空间，那么系统就无法分配连续的空间给用户。这就是内存碎片的问题。

## **5. 使用指针需要注意什么？**⭐⭐

1. 定义指针时，最好**将其初始化为 NULL**，这样可以避免使用未初始化的指针。
2. 在使用 malloc 或 new 分配内存之后，应该**立即检查指针的值是否为 NULL**，以防止在使用指针值为 NULL 的内存时出现问题。在 C++11 及更高版本中，使用 new 分配内存的时候，如果发生错误，会抛出异常，因此不需要显示判空。
3. 当使用指针指向数组或者动态分配的内存时，一定要记得为其赋初值，避免使用未被初始化的内存作为右值。
4. 小心避免数字或指针的**下标越界**，特别是一些常见的“多 1”或者“少 1”错误。
5. 在释放动态分配的内存时，务必确保**申请和释放是配对**的，**以防止内存泄漏**。
6. 使用 free 或 delete 释放内存后，**立即将指针设置为 NULL，以避免出现悬空指针（野指针）。**
7. 避免指针的多重间接性：多重间接性指的是通过多个指针进行连续的解引用操作。尽量避免过多的间接性，以提高代码的可读性和维护性。
8. 注意浅拷贝和深拷贝：如果指针指向的是动态分配的内存，涉及到对象的拷贝或赋值时，需要注意浅拷贝和深拷贝的区别。**深拷贝会复制整个对象及其指向的内存，而浅拷贝只是复制指针本身，可能导致多个指针指向同一块内存。**

## **6. 初始化为 0 的全局变量在 bss 还是 data**

初始化为 0 的全局变量通常会被分配到程序的 BSS（Block Started by Symbol）段。BSS 段是用于存放未初始化或初始化为 0 的全局变量和静态变量的一部分内存空间。在程序加载时，系统会自动将 BSS 段中的变量初始化为 0。

已经明确初始化为非零值的全局变量会被分配到程序的数据（Data）段。Data 段用于存放已经初始化的全局变量和静态变量。

总结来说，**未初始化和初始化为 0 的全局变量通常会被分配到 BSS 段，而已初始化为非零值的全局变量则会被分配到 Data 段。**