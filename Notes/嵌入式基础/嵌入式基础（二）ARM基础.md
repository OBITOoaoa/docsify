# 嵌入式基础（二）ARM基础

## 1.精简指令集和复杂指令集的区别⭐⭐⭐

### 精简指令集 (RISC)

- 精简指令集 (Reduced Instruction Set Computing) 具有**简洁、精简**的指令集，每条指令执行的操作都很基础，使得处理器设计更简单。
- RISC 处理器通常需要更多的指令来完成复杂的操作，但**每条指令执行的时间相对较短**。
- 采用**固定长度的指令格式**，简化了指令译码的工作，提高了流水线执行效率。
- RISC 处理器倾向于通过增加寄存器数量来加速运算，以减少内存访问的频率。

### 复杂指令集 (CISC)

- 复杂指令集 (Complex Instruction Set Computing) 包含**大量复杂**的指令，每条指令可以完成更多的工作，包括访存、运算等。
- CISC 处理器的指令通常更多样化，能够在**一条指令内完成复杂的操作**，因此每次执行的指令数较少。
- 具有**可变长度的指令格式**，使得指令译码较为复杂，执行速度可能会受到影响。
- CISC 处理器在设计上倾向于通过多种复杂的指令来减少内存访问次数，以提高程序的执行效率。

### 精简指令集和复杂指令集对比：

|              | 精简指令集         | 复杂指令集   |
| ------------ | ------------------ | ------------ |
| 指令数量     | 较多               | 较少         |
| 指令复杂度   | 简单               | 复杂         |
| 指令执行时间 | 短                 | 长           |
| 指令格式     | 固定长度           | 可变长度     |
| 寄存器的作用 | 重要，减少内存访问 | 相对不太重要 |

## 2.什么是DMA⭐⭐⭐⭐

### 什么是DMA

**DMA(Direct Memory Access，直接存储器访问) 提供在外设与内存、存储器和存储器、外设与外设之间的高速数据传输使用。它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU，在这个时间中，CPU对于内存的工作来说就无法使用。简单来说就是一个数据搬运工。**

### **DMA的意义主要体现在以下几个方面：**

1. **代替 CPU 搬运数据，为 CPU 减负**：数据搬运是一个耗时的任务，如果由 CPU 来执行数据传输操作，会占据 CPU 的大量时间和计算资源。通过利用 DMA 机制，外部设备可以直接与内存进行数据传输，无需 CPU 的参与，从而减轻了 CPU 的负担，使其能够专注于执行其他更重要的任务。
2. **数据搬运工作时效要求高**：某些场景下，数据的及时传输非常重要，例如实时流媒体、快速数据采集等应用。DMA 能够以高效率和高速度进行数据传输，满足对数据及时性的要求。
3. **数据搬运任务缺乏技术含量**：相比于其他计算任务，数据搬运任务相对简单，缺乏复杂的计算和逻辑操作。通过将数据搬运任务交给 DMA 执行，CPU 可以节省出宝贵的时间和资源，用于执行更具技术含量的计算和处理任务。

### DMA搬运数据

#### 1.搬运什么数据

搬运存储器、外设的数据：

外设指的是 spi、usart、iic、adc 等基于 APB1 、APB2 或 AHB 时钟的外设。

存储器包括自身的闪存(flash)或者内存(SRAM)以及外设的存储设备都可以作为访问地源或者目的。

#### 2.从哪里搬到哪里

1.存储器→存储器（例如：复制某特别大的数据 buf）

2.存储器→外设 （例如：将某数据 buf 写入串口 TDR 寄存器）

3.外设→存储器 （例如：将串口 RDR 寄存器写入某数据 buf）

## 3.说说你了解有哪些存储器类型⭐⭐⭐

| **存储器类型**           | **描述**                                                    |
| ------------------------ | ----------------------------------------------------------- |
| 内存 (RAM)               | 临时存储数据和程序的主要存储器类型。包括DRAM和SRAM。        |
| 只读存储器(ROM)          | 存储固定数据，如固件和BIOS。                                |
| 快闪存储器(Flash Memory) | 在断电的情况下可以存储数据。常用于SSD和便携设备。           |
| 磁盘存储器(Disk Storage) | 长期数据存储，包括硬盘驱动器(HDD)和固态硬盘(SSD)。          |
| Cache 存储器             | 加速访问主存储器中的数据的存储器，包括CPU缓存和磁盘缓存等。 |
| 存储介质                 | 长期数据备份和存档，包括磁带、光盘等。                      |

## 4.FreeRTOS、uCOS的区别⭐⭐

FreeRTOS 和 uC/OS 是两种实时操作系统(RTOS)，用于嵌入式系统开发。它们有一些显著的区别，包括以下方面：

**FreeRTOS：**

- 具有免费开源的版本，可**自由使用和定制**。
- 任务调度：FreeRTOS 使用**基于优先级的抢占式调度策略**，具有较低的上下文切换开销。
- 内核对象：FreeRTOS 提供一些基本的内核对象，如任务、队列和定时器等，具有**相对简单**的功能。
- 内存管理：可以选择静态内存分配或动态内存分配，可根据需求进行配置。
- 社区支持：具有活跃的社区支持，**频繁进行更新和改进**。

**uC/OS：**

- 提供免费和商业版本，商业版本提供额外的功能和支持。
- 任务调度：可配置为**抢占式或协作式调度**，灵活适应不同应用需求。
- 内核对象：提供丰富的内核对象，例如任务、信号量、邮箱、互斥锁等，功能**更为全面**。
- 内存管理：需要使用外部内存管理功能，用户可以根据需求选择适当的内存管理机制。
- 社区支持：社区相对稳定，**更新相对较慢**，具有较长时间的经验积累。

下面是 FreeRTOS 和 uC/OS 之间主要区别的表格罗列：

| **特征** | **FreeRTOS**             | **uC/OS**                |
| -------- | ------------------------ | ------------------------ |
| 许可     | 开源免费，灵活自由       | 免费和商业版本，商业支持 |
| 任务调度 | 基于优先级的抢占式       | 可配置为抢占式和协作式   |
| 内核对象 | 基本功能较为简单         | 提供丰富的内核对象       |
| 内存管理 | 静态或动态内存分配可选   | 需要使用外部内存管理功能 |
| 社区支持 | 活跃的社区支持，频繁更新 | 较为稳定，更新较慢       |

## 5.CPU 内存 虚拟内存 磁盘/硬盘 的关系⭐

1. **CPU（Central Processing Unit，中央处理器）**是计算机的大脑，**负责执行指令和处理数据**。它从内存中读取指令和数据，并对其进行处理。CPU 的运行速度和性能对系统的整体运行效率有着重要影响。
2. **内存（Random-access memory，随机存取存储器）**是计算机用来**临时存储数据和程序的地方**，其数据可以快速被 CPU 访问。内存的容量和速度直接影响着系统的运行速度和多任务处理能力。
3. **虚拟内存**是一种技术，通过它，计算机可以**使用磁盘空间来扩展内存的容量**。当物理内存不足时，系统会将一部分不常用的数据和程序存储到磁盘上，从而腾出内存空间给其他应用程序使用。这样，虚拟内存为系统提供了更大的地址空间和灵活的内存管理方式。
4. **磁盘/硬盘**是用来**长期存储数据和程序的设备**，通常包括机械硬盘（HDD）和固态硬盘（SSD）。磁盘上存储着操作系统、应用程序、用户数据等内容。计算机在启动时会从磁盘加载操作系统到内存中，并且在运行过程中会不断地向磁盘读写数据。

## 6.波特率是什么，为什么双方波特率要相同?⭐⭐⭐⭐

**波特率（Baud rate）是一种衡量数据传输速率的单位，表示每秒传输的信号变化次数。在串行通信中，波特率决定了数据传输的速率。**

### 为什么双方波特率要相同?

1. 在串行通信中，发送方将数据位一位一位地传输给接收方。发送方和接收方需要根据一个共同的时钟来保持同步，以确保数据的正确传输和解析。
2. **如果发送方和接收方的波特率不一致，就会出现问题。例如，如果发送方的波特率较高，而接收方的波特率较低，接收方可能无法及时接收到发送方发送的每个比特，导致数据传输错误。相反，如果接收方的波特率较高，而发送方的波特率较低，接收方就会在没有数据传输的时候出现等待时间。**
3. 因此，为了确保数据能够按正确的速率传输并且保持同步，通信双方需要使用相同的波特率。这样，发送方和接收方可以按照相同的时间间隔传输和接收数据，确保数据的准确性和完整性。

## 7.ARM和DSP有什么区别⭐

| **特征**          | **ARM处理器**                        | **DSP处理器**                            |
| ----------------- | ------------------------------------ | ---------------------------------------- |
| **应用领域**      | 通用处理器，用于控制和应用处理       | 专用于数字信号处理，如音频、视频、通信等 |
| **指令集**        | RISC架构                             | 固定点和浮点指令集                       |
| **主要功能**      | 通用处理器，适合通用用途的计算和控制 | 专用于数字信号处理和算法加速             |
| **算术/逻辑单元** | 用于通用计算                         | 专注于信号处理的算术逻辑单元             |
| **浮点运算**      | 适中支持浮点运算                     | 专注且高效的支持浮点运算                 |
| **架构**          | 适合通用用途的处理器架构             | 针对信号处理和并行计算优化的架构         |

## 8.ROM RAM的概念浅析⭐⭐

| **特征**   | **ROM(只读寄存器）**           | **RAM (随机存取存储器)**           |
| ---------- | ------------------------------ | ---------------------------------- |
| 可读写     | 只读                           | 可读写                             |
| 数据固化   | 是                             | 否                                 |
| 数据易失性 | 否                             | 是                                 |
| 数据保持性 | 断电时数据保持不变             | 断电时数据丢失                     |
| 访问方式   | 顺序读取                       | 随机读取                           |
| 用途       | 存储固件、引导程序、常量数据等 | 存储操作系统、应用程序、临时数据等 |
| 访问速度   | 相对较慢                       | 相对较快                           |
| 存储容量   | 通常较大                       | 通常较小                           |

## 9. 上拉输入 下拉输入 推挽输出 开漏输出⭐⭐⭐⭐

**上拉输入（Pull-Up Input）：**上拉输入是一种输入状态，该状态下，输入引脚连接一个**上拉电阻**，使其**保持高电平状态**。当没有外部信号输入时，输入引脚会被上拉电阻拉高。

**下拉输入（Pull-Down Input）：**下拉输入是一种输入状态，该状态下，输入引脚连接一个**下拉电阻**，使其**保持低电平状态**。当没有外部信号输入时，输入引脚会被下拉电阻拉低。

**推挽输出（Push-Pull Output）：**推挽输出是一种输出状态，该状态下，输出引脚能够提供电流流入或流出。在高电平状态下，输出引脚提供一个高电平信号，而在低电平状态下，输出引脚提供一个低电平信号。

**开漏输出（Open-Drain Output）：**开漏输出是一种输出状态，该状态下，输出引脚可以将其连接到地（低电平状态）或离开（浮空）以实现低电平状态。它需要外部上拉电阻来将引脚拉高，因此输出引脚只能拉低或浮空，无法提供高电平。

## 10.请使用stm32写一个点灯⭐⭐⭐⭐

```c
#include "stm32f4xx_hal.h"  HAL库 

/* 使用的 GPIO 引脚 */
#define LED_PIN GPIO_PIN_13
#define LED_PORT GPIOG

int main(void)
{
  HAL_Init();  // 初始化 HAL 库

  /* 启用 GPIOG 时钟 */
  __HAL_RCC_GPIOG_CLK_ENABLE();

  /* 配置 GPIO 引脚为输出模式 */
  GPIO_InitTypeDef GPIO_InitStruct;
  GPIO_InitStruct.Pin = LED_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  // 输出模式
  GPIO_InitStruct.Pull = GPIO_NOPULL;  // 无
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  // 低速
  HAL_GPIO_Init(LED_PORT, &GPIO_InitStruct);  // 初始化 LED 引脚

  while (1)
  {
    /* 点亮 LED */
    HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET);

    /* 延时一段时间 */
    HAL_Delay(1000);  // 延时1秒

    /* 熄灭 LED */
    HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET);

    /* 延时一段时间 */
    HAL_Delay(1000);  // 延时1秒
  }
}
```